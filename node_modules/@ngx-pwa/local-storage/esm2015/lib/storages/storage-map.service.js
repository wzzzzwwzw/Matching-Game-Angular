import { Injectable, Inject } from '@angular/core';
import { throwError, of, ReplaySubject } from 'rxjs';
import { mergeMap, catchError, tap } from 'rxjs/operators';
import { JSONValidator } from '../validation/json-validator';
import { IndexedDBDatabase } from '../databases/indexeddb-database';
import { LocalStorageDatabase } from '../databases/localstorage-database';
import { MemoryDatabase } from '../databases/memory-database';
import { LocalDatabase } from '../databases/local-database';
import { IDB_BROKEN_ERROR } from '../databases/exceptions';
import { LS_PREFIX } from '../tokens';
import { ValidationError } from './exceptions';
import * as i0 from "@angular/core";
import * as i1 from "../databases/local-database";
import * as i2 from "../validation/json-validator";
import * as i3 from "../tokens";
export class StorageMap {
    /**
     * Constructor params are provided by Angular (but can also be passed manually in tests)
     * @param database Storage to use
     * @param jsonValidator Validator service
     * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain or for interoperability
     */
    constructor(database, jsonValidator = new JSONValidator(), LSPrefix = '') {
        this.database = database;
        this.jsonValidator = jsonValidator;
        this.LSPrefix = LSPrefix;
        this.notifiers = new Map();
    }
    /**
     * **Number of items** in storage, wrapped in an `Observable`.
     *
     * @example
     * this.storageMap.size.subscribe((size) => {
     *   console.log(size);
     * });
     */
    get size() {
        return this.database.size
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(() => this.database.size));
    }
    /**
     * Tells you which storage engine is used. *Only useful for interoperability.*
     * Note that due to some browsers issues in some special contexts
     * (Firefox private mode and Safari cross-origin iframes),
     * **this information may be wrong at initialization,**
     * as the storage could fallback from `indexedDB` to `localStorage`
     * only after a first read or write operation.
     * @returns Storage engine used
     *
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'indexedDB') {}
     */
    get backingEngine() {
        if (this.database instanceof IndexedDBDatabase) {
            return 'indexedDB';
        }
        else if (this.database instanceof LocalStorageDatabase) {
            return 'localStorage';
        }
        else if (this.database instanceof MemoryDatabase) {
            return 'memory';
        }
        else {
            return 'unknown';
        }
    }
    /**
     * Info about `indexedDB` database. *Only useful for interoperability.*
     * @returns `indexedDB` database name, store name and database version.
     * **Values will be empty if the storage is not `indexedDB`,**
     * **so it should be used after an engine check**.
     *
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'indexedDB') {
     *   const { database, store, version } = this.storageMap.backingStore;
     * }
     */
    get backingStore() {
        return (this.database instanceof IndexedDBDatabase) ?
            this.database.backingStore :
            { database: '', store: '', version: 0 };
    }
    /**
     * Info about `localStorage` fallback storage. *Only useful for interoperability.*
     * @returns `localStorage` prefix.
     * **Values will be empty if the storage is not `localStorage`,**
     * **so it should be used after an engine check**.
     *
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'localStorage') {
     *   const { prefix } = this.storageMap.fallbackBackingStore;
     * }
     */
    get fallbackBackingStore() {
        return (this.database instanceof LocalStorageDatabase) ?
            { prefix: this.database.prefix } :
            { prefix: '' };
    }
    get(key, schema) {
        /* Get the data in storage */
        return this.database.get(key).pipe(
        /* Check if `indexedDb` is broken */
        this.catchIDBBroken(() => this.database.get(key)), mergeMap((data) => {
            /* No need to validate if the data is empty */
            if ((data === undefined) || (data === null)) {
                return of(undefined);
            }
            else if (schema) {
                /* Validate data against a JSON schema if provided */
                if (!this.jsonValidator.validate(data, schema)) {
                    return throwError(new ValidationError());
                }
                /* Data have been checked, so it's OK to cast */
                return of(data);
            }
            /* Cast to unknown as the data wasn't checked */
            return of(data);
        }));
    }
    /**
     * Set an item in storage.
     * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.
     * @param key The item's key
     * @param data The item's value
     * @param schema Optional JSON schema to validate the data
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.storageMap.set('key', 'value').subscribe(() => {});
     */
    set(key, data, schema) {
        /* Storing `undefined` or `null` is useless and can cause issues in `indexedDb` in some browsers,
         * so removing item instead for all storages to have a consistent API */
        if ((data === undefined) || (data === null)) {
            return this.delete(key);
        }
        /* Validate data against a JSON schema if provided */
        if (schema && !this.jsonValidator.validate(data, schema)) {
            return throwError(new ValidationError());
        }
        return this.database.set(key, data).pipe(
        /* Catch if `indexedDb` is broken */
        this.catchIDBBroken(() => this.database.set(key, data)), 
        /* Notify watchers (must be last because it should only happen if the operation succeeds) */
        tap(() => { this.notify(key, data); }));
    }
    /**
     * Delete an item in storage
     * @param key The item's key
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.storageMap.delete('key').subscribe(() => {});
     */
    delete(key) {
        return this.database.delete(key).pipe(
        /* Catch if `indexedDb` is broken */
        this.catchIDBBroken(() => this.database.delete(key)), 
        /* Notify watchers (must be last because it should only happen if the operation succeeds) */
        tap(() => { this.notify(key, undefined); }));
    }
    /**
     * Delete all items in storage
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.storageMap.clear().subscribe(() => {});
     */
    clear() {
        return this.database.clear().pipe(
        /* Catch if `indexedDb` is broken */
        this.catchIDBBroken(() => this.database.clear()), 
        /* Notify watchers (must be last because it should only happen if the operation succeeds) */
        tap(() => {
            for (const key of this.notifiers.keys()) {
                this.notify(key, undefined);
            }
        }));
    }
    /**
     * Get all keys stored in storage. Note **this is an *iterating* `Observable`**:
     * * if there is no key, the `next` callback will not be invoked,
     * * if you need to wait the whole operation to end, be sure to act in the `complete` callback,
     * as this `Observable` can emit several values and so will invoke the `next` callback several times.
     * @returns A list of the keys wrapped in a RxJS `Observable`
     *
     * @example
     * this.storageMap.keys().subscribe({
     *   next: (key) => { console.log(key); },
     *   complete: () => { console.log('Done'); },
     * });
     */
    keys() {
        return this.database.keys()
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(() => this.database.keys()));
    }
    /**
     * Tells if a key exists in storage
     * @returns A RxJS `Observable` telling if the key exists
     *
     * @example
     * this.storageMap.has('key').subscribe((hasKey) => {
     *   if (hasKey) {}
     * });
     */
    has(key) {
        return this.database.has(key)
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(() => this.database.has(key)));
    }
    watch(key, schema) {
        /* Check if there is already a notifier */
        if (!this.notifiers.has(key)) {
            this.notifiers.set(key, new ReplaySubject(1));
        }
        /* Non-null assertion is required because TypeScript doesn't narrow `.has()` yet */
        // tslint:disable-next-line: no-non-null-assertion
        const notifier = this.notifiers.get(key);
        /* Get the current item value */
        (schema ? this.get(key, schema) : this.get(key)).subscribe({
            next: (result) => notifier.next(result),
            error: (error) => notifier.error(error),
        });
        /* Only the public API of the `Observable` should be returned */
        return (schema ?
            notifier.asObservable() :
            notifier.asObservable());
    }
    /**
     * Notify when a value changes
     * @param key The item's key
     * @param data The new value
     */
    notify(key, value) {
        const notifier = this.notifiers.get(key);
        if (notifier) {
            notifier.next(value);
        }
    }
    /**
     * RxJS operator to catch if `indexedDB` is broken
     * @param operationCallback Callback with the operation to redo
     */
    catchIDBBroken(operationCallback) {
        return catchError((error) => {
            /* Check if `indexedDB` is broken based on error message (the specific error class seems to be lost in the process) */
            if ((error !== undefined) && (error !== null) && (error.message === IDB_BROKEN_ERROR)) {
                /* When storage is fully disabled in browser (via the "Block all cookies" option),
                 * just trying to check `localStorage` variable causes a security exception.
                 * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118
                 */
                try {
                    if ('getItem' in localStorage) {
                        /* Fallback to `localStorage` if available */
                        this.database = new LocalStorageDatabase(this.LSPrefix);
                    }
                    else {
                        /* Fallback to memory storage otherwise */
                        this.database = new MemoryDatabase();
                    }
                }
                catch (_a) {
                    /* Fallback to memory storage otherwise */
                    this.database = new MemoryDatabase();
                }
                /* Redo the operation */
                return operationCallback();
            }
            else {
                /* Otherwise, rethrow the error */
                return throwError(error);
            }
        });
    }
}
StorageMap.ɵprov = i0.ɵɵdefineInjectable({ factory: function StorageMap_Factory() { return new StorageMap(i0.ɵɵinject(i1.LocalDatabase), i0.ɵɵinject(i2.JSONValidator), i0.ɵɵinject(i3.LS_PREFIX)); }, token: StorageMap, providedIn: "root" });
StorageMap.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
StorageMap.ctorParameters = () => [
    { type: LocalDatabase },
    { type: JSONValidator },
    { type: undefined, decorators: [{ type: Inject, args: [LS_PREFIX,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZS1tYXAuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtcHdhL2xvY2FsLXN0b3JhZ2Uvc3JjLyIsInNvdXJjZXMiOlsibGliL3N0b3JhZ2VzL3N0b3JhZ2UtbWFwLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkQsT0FBTyxFQUFjLFVBQVUsRUFBRSxFQUFFLEVBQW9CLGFBQWEsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNuRixPQUFPLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQU0zRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDN0QsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDcEUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDMUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQzlELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxjQUFjLENBQUM7Ozs7O0FBSy9DLE1BQU0sT0FBTyxVQUFVO0lBSXJCOzs7OztPQUtHO0lBQ0gsWUFDWSxRQUF1QixFQUN2QixnQkFBK0IsSUFBSSxhQUFhLEVBQUUsRUFDL0IsV0FBVyxFQUFFO1FBRmhDLGFBQVEsR0FBUixRQUFRLENBQWU7UUFDdkIsa0JBQWEsR0FBYixhQUFhLENBQXFDO1FBQy9CLGFBQVEsR0FBUixRQUFRLENBQUs7UUFYbEMsY0FBUyxHQUFH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QzdDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7cUJBRXpEO3lCQUFNO3dCQUVMLDBDQUEwQzt3QkFDMUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGNBQWMsRUFBRSxDQUFDO3FCQUV0QztpQkFFRjtnQkFBQyxXQUFNO29CQUVOLDBDQUEwQztvQkFDMUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGNBQWMsRUFBRSxDQUFDO2lCQUV0QztnQkFFRCx3QkFBd0I7Z0JBQ3hCLE9BQU8saUJBQWlCLEVBQUUsQ0FBQzthQUU1QjtpQkFBTTtnQkFFTCxrQ0FBa0M7Z0JBQ2xDLE9BQU8sVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBRTFCO1FBRUgsQ0FBQyxDQUFDLENBQUM7SUFFTCxDQUFDOzs7O1lBcGVGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7O1lBUFEsYUFBYTtZQUpiLGFBQWE7NENBeUJqQixNQUFNLFNBQUMsU0FBUyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgdGhyb3dFcnJvciwgb2YsIE9wZXJhdG9yRnVuY3Rpb24sIFJlcGxheVN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1lcmdlTWFwLCBjYXRjaEVycm9yLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7XG4gIEpTT05TY2hlbWEsIEpTT05TY2hlbWFCb29sZWFuLCBKU09OU2NoZW1hSW50ZWdlcixcbiAgSlNPTlNjaGVtYU51bWJlciwgSlNPTlNjaGVtYVN0cmluZywgSlNPTlNjaGVtYUFycmF5T2Zcbn0gZnJvbSAnLi4vdmFsaWRhdGlvbi9qc29uLXNjaGVtYSc7XG5pbXBvcnQgeyBKU09OVmFsaWRhdG9yIH0gZnJvbSAnLi4vdmFsaWRhdGlvbi9qc29uLXZhbGlkYXRvcic7XG5pbXBvcnQgeyBJbmRleGVkREJEYXRhYmFzZSB9IGZyb20gJy4uL2RhdGFiYXNlcy9pbmRleGVkZGItZGF0YWJhc2UnO1xuaW1wb3J0IHsgTG9jYWxTdG9yYWdlRGF0YWJhc2UgfSBmcm9tICcuLi9kYXRhYmFzZXMvbG9jYWxzdG9yYWdlLWRhdGFiYXNlJztcbmltcG9ydCB7IE1lbW9yeURhdGFiYXNlIH0gZnJvbSAnLi4vZGF0YWJhc2VzL21lbW9yeS1kYXRhYmFzZSc7XG5pbXBvcnQgeyBMb2NhbERhdGFiYXNlIH0gZnJvbSAnLi4vZGF0YWJhc2VzL2xvY2FsLWRhdGFiYXNlJztcbmltcG9ydCB7IElEQl9CUk9LRU5fRVJST1IgfSBmcm9tICcuLi9kYXRhYmFzZXMvZXhjZXB0aW9ucyc7XG5pbXBvcnQgeyBMU19QUkVGSVggfSBmcm9tICcuLi90b2tlbnMnO1xuaW1wb3J0IHsgVmFsaWRhdGlvbkVycm9yIH0gZnJvbSAnLi9leGNlcHRpb25zJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgU3RvcmFnZU1hcCB7XG5cbiAgcHJvdGVjdGVkIG5vdGlmaWVycyA9IG5ldyBNYXA8c3RyaW5nLCBSZXBsYXlTdWJqZWN0PHVua25vd24+PigpO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBwYXJhbXMgYXJlIHByb3ZpZGVkIGJ5IEFuZ3VsYXIgKGJ1dCBjYW4gYWxzbyBiZSBwYXNzZWQgbWFudWFsbHkgaW4gdGVzdHMpXG4gICAqIEBwYXJhbSBkYXRhYmFzZSBTdG9yYWdlIHRvIHVzZVxuICAgKiBAcGFyYW0ganNvblZhbGlkYXRvciBWYWxpZGF0b3Igc2VydmljZVxuICAgKiBAcGFyYW0gTFNQcmVmaXggUHJlZml4IGZvciBgbG9jYWxTdG9yYWdlYCBrZXlzIHRvIGF2b2lkIGNvbGxpc2lvbiBmb3IgbXVsdGlwbGUgYXBwcyBvbiB0aGUgc2FtZSBzdWJkb21haW4gb3IgZm9yIGludGVyb3BlcmFiaWxpdHlcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBkYXRhYmFzZTogTG9jYWxEYXRhYmFzZSxcbiAgICBwcm90ZWN0ZWQganNvblZhbGlkYXRvcjogSlNPTlZhbGlkYXRvciA9IG5ldyBKU09OVmFsaWRhdG9yKCksXG4gICAgQEluamVjdChMU19QUkVGSVgpIHByb3RlY3RlZCBMU1ByZWZpeCA9ICcnLFxuICApIHt9XG5cbiAgLyoqXG4gICAqICoqTnVtYmVyIG9mIGl0ZW1zKiogaW4gc3RvcmFnZSwgd3JhcHBlZCBpbiBhbiBgT2JzZXJ2YWJsZWAuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMuc3RvcmFnZU1hcC5zaXplLnN1YnNjcmliZSgoc2l6ZSkgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKHNpemUpO1xuICAgKiB9KTtcbiAgICovXG4gIGdldCBzaXplKCk6IE9ic2VydmFibGU8bnVtYmVyPiB7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhYmFzZS5zaXplXG4gICAgICAvKiBDYXRjaCBpZiBgaW5kZXhlZERiYCBpcyBicm9rZW4gKi9cbiAgICAgIC5waXBlKHRoaXMuY2F0Y2hJREJCcm9rZW4oKCkgPT4gdGhpcy5kYXRhYmFzZS5zaXplKSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBUZWxscyB5b3Ugd2hpY2ggc3RvcmFnZSBlbmdpbmUgaXMgdXNlZC4gKk9ubHkgdXNlZnVsIGZvciBpbnRlcm9wZXJhYmlsaXR5LipcbiAgICogTm90ZSB0aGF0IGR1ZSB0byBzb21lIGJyb3dzZXJzIGlzc3VlcyBpbiBzb21lIHNwZWNpYWwgY29udGV4dHNcbiAgICogKEZpcmVmb3ggcHJpdmF0ZSBtb2RlIGFuZCBTYWZhcmkgY3Jvc3Mtb3JpZ2luIGlmcmFtZXMpLFxuICAgKiAqKnRoaXMgaW5mb3JtYXRpb24gbWF5IGJlIHdyb25nIGF0IGluaXRpYWxpemF0aW9uLCoqXG4gICAqIGFzIHRoZSBzdG9yYWdlIGNvdWxkIGZhbGxiYWNrIGZyb20gYGluZGV4ZWREQmAgdG8gYGxvY2FsU3RvcmFnZWBcbiAgICogb25seSBhZnRlciBhIGZpcnN0IHJlYWQgb3Igd3JpdGUgb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyBTdG9yYWdlIGVuZ2luZSB1c2VkXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYWluL2RvY3MvSU5URVJPUEVSQUJJTElUWS5tZH1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaWYgKHRoaXMuc3RvcmFnZU1hcC5iYWNraW5nRW5naW5lID09PSAnaW5kZXhlZERCJykge31cbiAgICovXG4gIGdldCBiYWNraW5nRW5naW5lKCk6ICdpbmRleGVkREInIHwgJ2xvY2FsU3RvcmFnZScgfMKgJ21lbW9yeScgfCAndW5rbm93bicge1xuXG4gICAgaWYgKHRoaXMuZGF0YWJhc2UgaW5zdGFuY2VvZiBJbmRleGVkREJEYXRhYmFzZSkge1xuXG4gICAgICByZXR1cm4gJ2luZGV4ZWREQic7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YWJhc2UgaW5zdGFuY2VvZiBMb2NhbFN0b3JhZ2VEYXRhYmFzZSkge1xuXG4gICAgICByZXR1cm4gJ2xvY2FsU3RvcmFnZSc7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YWJhc2UgaW5zdGFuY2VvZiBNZW1vcnlEYXRhYmFzZSkge1xuXG4gICAgICByZXR1cm4gJ21lbW9yeSc7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICByZXR1cm4gJ3Vua25vd24nO1xuXG4gICAgfVxuXG4gIH1cblxuICAvKipcbiAgICogSW5mbyBhYm91dCBgaW5kZXhlZERCYCBkYXRhYmFzZS4gKk9ubHkgdXNlZnVsIGZvciBpbnRlcm9wZXJhYmlsaXR5LipcbiAgICogQHJldHVybnMgYGluZGV4ZWREQmAgZGF0YWJhc2UgbmFtZSwgc3RvcmUgbmFtZSBhbmQgZGF0YWJhc2UgdmVyc2lvbi5cbiAgICogKipWYWx1ZXMgd2lsbCBiZSBlbXB0eSBpZiB0aGUgc3RvcmFnZSBpcyBub3QgYGluZGV4ZWREQmAsKipcbiAgICogKipzbyBpdCBzaG91bGQgYmUgdXNlZCBhZnRlciBhbiBlbmdpbmUgY2hlY2sqKi5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9ibG9iL21haW4vZG9jcy9JTlRFUk9QRVJBQklMSVRZLm1kfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpZiAodGhpcy5zdG9yYWdlTWFwLmJhY2tpbmdFbmdpbmUgPT09ICdpbmRleGVkREInKSB7XG4gICAqICAgY29uc3QgeyBkYXRhYmFzZSwgc3RvcmUsIHZlcnNpb24gfSA9IHRoaXMuc3RvcmFnZU1hcC5iYWNraW5nU3RvcmU7XG4gICAqIH1cbiAgICovXG4gIGdldCBiYWNraW5nU3RvcmUoKTogeyBkYXRhYmFzZTogc3RyaW5nLCBzdG9yZTogc3RyaW5nLCB2ZXJzaW9uOiBudW1iZXIgfSB7XG5cbiAgICByZXR1cm4gKHRoaXMuZGF0YWJhc2UgaW5zdGFuY2VvZiBJbmRleGVkREJEYXRhYmFzZSkgP1xuICAgICAgdGhpcy5kYXRhYmFzZS5iYWNraW5nU3RvcmUgOlxuICAgICAgeyBkYXRhYmFzZTogJycsIHN0b3JlOiAnJywgdmVyc2lvbjogMCB9O1xuXG4gIH1cblxuICAvKipcbiAgICogSW5mbyBhYm91dCBgbG9jYWxTdG9yYWdlYCBmYWxsYmFjayBzdG9yYWdlLiAqT25seSB1c2VmdWwgZm9yIGludGVyb3BlcmFiaWxpdHkuKlxuICAgKiBAcmV0dXJucyBgbG9jYWxTdG9yYWdlYCBwcmVmaXguXG4gICAqICoqVmFsdWVzIHdpbGwgYmUgZW1wdHkgaWYgdGhlIHN0b3JhZ2UgaXMgbm90IGBsb2NhbFN0b3JhZ2VgLCoqXG4gICAqICoqc28gaXQgc2hvdWxkIGJlIHVzZWQgYWZ0ZXIgYW4gZW5naW5lIGNoZWNrKiouXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYWluL2RvY3MvSU5URVJPUEVSQUJJTElUWS5tZH1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaWYgKHRoaXMuc3RvcmFnZU1hcC5iYWNraW5nRW5naW5lID09PSAnbG9jYWxTdG9yYWdlJykge1xuICAgKiAgIGNvbnN0IHsgcHJlZml4IH0gPSB0aGlzLnN0b3JhZ2VNYXAuZmFsbGJhY2tCYWNraW5nU3RvcmU7XG4gICAqIH1cbiAgICovXG4gIGdldCBmYWxsYmFja0JhY2tpbmdTdG9yZSgpOiB7IHByZWZpeDogc3RyaW5nIH0ge1xuXG4gICAgcmV0dXJuICh0aGlzLmRhdGFiYXNlIGluc3RhbmNlb2YgTG9jYWxTdG9yYWdlRGF0YWJhc2UpID9cbiAgICAgIHsgcHJlZml4OiB0aGlzLmRhdGFiYXNlLnByZWZpeCB9IDpcbiAgICAgIHsgcHJlZml4OiAnJyB9O1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGl0ZW0gdmFsdWUgaW4gc3RvcmFnZS5cbiAgICogVGhlIHNpZ25hdHVyZSBoYXMgbWFueSBvdmVybG9hZHMgZHVlIHRvIHZhbGlkYXRpb24sICoqcGxlYXNlIHJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uLioqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYWluL2RvY3MvVkFMSURBVElPTi5tZH1cbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcGFyYW0gc2NoZW1hIE9wdGlvbmFsIEpTT04gc2NoZW1hIHRvIHZhbGlkYXRlIHRoZSBkYXRhXG4gICAqIEByZXR1cm5zIFRoZSBpdGVtJ3MgdmFsdWUgaWYgdGhlIGtleSBleGlzdHMsIGB1bmRlZmluZWRgIG90aGVyd2lzZSwgd3JhcHBlZCBpbiBhIFJ4SlMgYE9ic2VydmFibGVgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMuc3RvcmFnZU1hcC5nZXQoJ2tleScsIHsgdHlwZTogJ3N0cmluZycgfSkuc3Vic2NyaWJlKChyZXN1bHQpID0+IHtcbiAgICogICByZXN1bHQ7IC8vIHN0cmluZyBvciB1bmRlZmluZWRcbiAgICogfSk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGludGVyZmFjZSBVc2VyIHtcbiAgICogICBmaXJzdE5hbWU6IHN0cmluZztcbiAgICogICBsYXN0TmFtZT86IHN0cmluZztcbiAgICogfVxuICAgKlxuICAgKiBjb25zdCBzY2hlbWEgPSB7XG4gICAqICAgdHlwZTogJ29iamVjdCcsXG4gICAqICAgcHJvcGVydGllczoge1xuICAgKiAgICAgZmlyc3ROYW1lOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAqICAgICBsYXN0TmFtZTogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgKiAgIH0sXG4gICAqICAgcmVxdWlyZWQ6IFsnZmlyc3ROYW1lJ11cbiAgICogfTtcbiAgICpcbiAgICogdGhpcy5zdG9yYWdlTWFwLmdldDxVc2VyPigndXNlcicsIHNjaGVtYSkuc3Vic2NyaWJlKCh1c2VyKSA9PiB7XG4gICAqICAgaWYgKHVzZXIpIHtcbiAgICogICAgIHVzZXIuZmlyc3ROYW1lO1xuICAgKiAgIH1cbiAgICogfSk7XG4gICAqL1xuICBnZXQoa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPHVua25vd24+O1xuICBnZXQ8VCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYVN0cmluZyk6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIGdldDxUIGV4dGVuZHMgbnVtYmVyID0gbnVtYmVyPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hSW50ZWdlciB8IEpTT05TY2hlbWFOdW1iZXIpOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+O1xuICBnZXQ8VCBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQm9vbGVhbik6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIGdldDxUIGV4dGVuZHMgcmVhZG9ubHkgc3RyaW5nW10gPSBzdHJpbmdbXT4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUFycmF5T2Y8SlNPTlNjaGVtYVN0cmluZz4pOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+O1xuICBnZXQ8VCBleHRlbmRzIHJlYWRvbmx5IG51bWJlcltdID0gbnVtYmVyW10+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFBcnJheU9mPEpTT05TY2hlbWFJbnRlZ2VyIHwgSlNPTlNjaGVtYU51bWJlcj4pOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+O1xuICBnZXQ8VCBleHRlbmRzIHJlYWRvbmx5IGJvb2xlYW5bXSA9IGJvb2xlYW5bXT4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUFycmF5T2Y8SlNPTlNjaGVtYUJvb2xlYW4+KTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBjYXN0IGlzIHVzZWxlc3MgaGVyZSBhbmQgZG9lc24ndCBtYXRjaCB0aGUgSlNPTiBzY2hlbWEuIEp1c3QgcmVtb3ZlIHRoZSBjYXN0LlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2Jsb2IvbWFpbi9kb2NzL1ZBTElEQVRJT04ubWR9XG4gICAqL1xuICBnZXQ8VCA9IHN0cmluZz4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYVN0cmluZyk6IE9ic2VydmFibGU8c3RyaW5nIHwgdW5kZWZpbmVkPjtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBjYXN0IGlzIHVzZWxlc3MgaGVyZSBhbmQgZG9lc24ndCBtYXRjaCB0aGUgSlNPTiBzY2hlbWEuIEp1c3QgcmVtb3ZlIHRoZSBjYXN0LlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2Jsb2IvbWFpbi9kb2NzL1ZBTElEQVRJT04ubWR9XG4gICAqL1xuICBnZXQ8VCA9IG51bWJlcj4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUludGVnZXIgfCBKU09OU2NoZW1hTnVtYmVyKTogT2JzZXJ2YWJsZTxudW1iZXIgfCB1bmRlZmluZWQ+O1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVGhlIGNhc3QgaXMgdXNlbGVzcyBoZXJlIGFuZCBkb2Vzbid0IG1hdGNoIHRoZSBKU09OIHNjaGVtYS4gSnVzdCByZW1vdmUgdGhlIGNhc3QuXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYWluL2RvY3MvVkFMSURBVElPTi5tZH1cbiAgICovXG4gIGdldDxUID0gYm9vbGVhbj4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUJvb2xlYW4pOiBPYnNlcnZhYmxlPGJvb2xlYW4gfCB1bmRlZmluZWQ+O1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVGhlIGNhc3QgaXMgdXNlbGVzcyBoZXJlIGFuZCBkb2Vzbid0IG1hdGNoIHRoZSBKU09OIHNjaGVtYS4gSnVzdCByZW1vdmUgdGhlIGNhc3QuXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYWluL2RvY3MvVkFMSURBVElPTi5tZH1cbiAgICovXG4gIGdldDxUID0gc3RyaW5nW10+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFBcnJheU9mPEpTT05TY2hlbWFTdHJpbmc+KTogT2JzZXJ2YWJsZTxzdHJpbmdbXSB8IHVuZGVmaW5lZD47XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBUaGUgY2FzdCBpcyB1c2VsZXNzIGhlcmUgYW5kIGRvZXNuJ3QgbWF0Y2ggdGhlIEpTT04gc2NoZW1hLiBKdXN0IHJlbW92ZSB0aGUgY2FzdC5cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9ibG9iL21haW4vZG9jcy9WQUxJREFUSU9OLm1kfVxuICAgKi9cbiAgZ2V0PFQgPSBudW1iZXJbXT4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUFycmF5T2Y8SlNPTlNjaGVtYUludGVnZXIgfCBKU09OU2NoZW1hTnVtYmVyPik6IE9ic2VydmFibGU8bnVtYmVyW10gfCB1bmRlZmluZWQ+O1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVGhlIGNhc3QgaXMgdXNlbGVzcyBoZXJlIGFuZCBkb2Vzbid0IG1hdGNoIHRoZSBKU09OIHNjaGVtYS4gSnVzdCByZW1vdmUgdGhlIGNhc3QuXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYWluL2RvY3MvVkFMSURBVElPTi5tZH1cbiAgICovXG4gIGdldDxUID0gYm9vbGVhbltdPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXlPZjxKU09OU2NoZW1hQm9vbGVhbj4pOiBPYnNlcnZhYmxlPGJvb2xlYW5bXSB8IHVuZGVmaW5lZD47XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBBIGNhc3QgaXMgcmVxdWlyZWQgaGVyZSwgb3RoZXJ3aXNlIHRoZSByZXR1cm4gd2lsbCBiZSBgdW5rbm93bmAgZGVzcGl0ZSBhIEpTT04gc2NoZW1hIHdhcyBwcm92aWRlZC5cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9ibG9iL21haW4vZG9jcy9WQUxJREFUSU9OLm1kfVxuICAgKi9cbiAgZ2V0KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWEpOiBPYnNlcnZhYmxlPHVua25vd24gfCB1bmRlZmluZWQ+O1xuICBnZXQ8VD4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYSk6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBUaGUgY2FzdCBpcyB1c2VsZXNzIGhlcmU6IGFzIG5vIEpTT04gc2NoZW1hIHdhcyBwcm92aWRlZCBmb3IgdmFsaWRhdGlvbiwgdGhlIHJlc3VsdCB3aWxsIHN0aWxsIGJlIGB1bmtub3duYC5cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9ibG9iL21haW4vZG9jcy9WQUxJREFUSU9OLm1kfVxuICAgKi9cbiAgZ2V0PFQ+KGtleTogc3RyaW5nLCBzY2hlbWE/OiBKU09OU2NoZW1hKTogT2JzZXJ2YWJsZTx1bmtub3duPjtcbiAgZ2V0PFQgPSB1bmtub3duPihrZXk6IHN0cmluZywgc2NoZW1hPzogSlNPTlNjaGVtYSk6IE9ic2VydmFibGU8dW5rbm93bj4ge1xuXG4gICAgLyogR2V0IHRoZSBkYXRhIGluIHN0b3JhZ2UgKi9cbiAgICByZXR1cm4gdGhpcy5kYXRhYmFzZS5nZXQoa2V5KS5waXBlKFxuICAgICAgLyogQ2hlY2sgaWYgYGluZGV4ZWREYmAgaXMgYnJva2VuICovXG4gICAgICB0aGlzLmNhdGNoSURCQnJva2VuKCgpID0+IHRoaXMuZGF0YWJhc2UuZ2V0KGtleSkpLFxuICAgICAgbWVyZ2VNYXAoKGRhdGEpID0+IHtcblxuICAgICAgICAvKiBObyBuZWVkIHRvIHZhbGlkYXRlIGlmIHRoZSBkYXRhIGlzIGVtcHR5ICovXG4gICAgICAgIGlmICgoZGF0YSA9PT0gdW5kZWZpbmVkKSB8fCAoZGF0YSA9PT0gbnVsbCkpIHtcblxuICAgICAgICAgIHJldHVybiBvZih1bmRlZmluZWQpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoc2NoZW1hKSB7XG5cbiAgICAgICAgICAvKiBWYWxpZGF0ZSBkYXRhIGFnYWluc3QgYSBKU09OIHNjaGVtYSBpZiBwcm92aWRlZCAqL1xuICAgICAgICAgIGlmICghdGhpcy5qc29uVmFsaWRhdG9yLnZhbGlkYXRlKGRhdGEsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKG5ldyBWYWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyogRGF0YSBoYXZlIGJlZW4gY2hlY2tlZCwgc28gaXQncyBPSyB0byBjYXN0ICovXG4gICAgICAgICAgcmV0dXJuIG9mKGRhdGEgYXMgVCB8IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIENhc3QgdG8gdW5rbm93biBhcyB0aGUgZGF0YSB3YXNuJ3QgY2hlY2tlZCAqL1xuICAgICAgICByZXR1cm4gb2YoZGF0YSBhcyB1bmtub3duKTtcblxuICAgICAgfSksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhbiBpdGVtIGluIHN0b3JhZ2UuXG4gICAqIE5vdGUgdGhhdCBzZXR0aW5nIGBudWxsYCBvciBgdW5kZWZpbmVkYCB3aWxsIHJlbW92ZSB0aGUgaXRlbSB0byBhdm9pZCBzb21lIGJyb3dzZXJzIGlzc3Vlcy5cbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcGFyYW0gZGF0YSBUaGUgaXRlbSdzIHZhbHVlXG4gICAqIEBwYXJhbSBzY2hlbWEgT3B0aW9uYWwgSlNPTiBzY2hlbWEgdG8gdmFsaWRhdGUgdGhlIGRhdGFcbiAgICogQHJldHVybnMgQSBSeEpTIGBPYnNlcnZhYmxlYCB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLnN0b3JhZ2VNYXAuc2V0KCdrZXknLCAndmFsdWUnKS5zdWJzY3JpYmUoKCkgPT4ge30pO1xuICAgKi9cbiAgc2V0KGtleTogc3RyaW5nLCBkYXRhOiB1bmtub3duLCBzY2hlbWE/OiBKU09OU2NoZW1hKTogT2JzZXJ2YWJsZTx1bmRlZmluZWQ+IHtcblxuICAgIC8qIFN0b3JpbmcgYHVuZGVmaW5lZGAgb3IgYG51bGxgIGlzIHVzZWxlc3MgYW5kIGNhbiBjYXVzZSBpc3N1ZXMgaW4gYGluZGV4ZWREYmAgaW4gc29tZSBicm93c2VycyxcbiAgICAgKiBzbyByZW1vdmluZyBpdGVtIGluc3RlYWQgZm9yIGFsbCBzdG9yYWdlcyB0byBoYXZlIGEgY29uc2lzdGVudCBBUEkgKi9cbiAgICBpZiAoKGRhdGEgPT09IHVuZGVmaW5lZCkgfHwgKGRhdGEgPT09IG51bGwpKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxldGUoa2V5KTtcbiAgICB9XG5cbiAgICAvKiBWYWxpZGF0ZSBkYXRhIGFnYWluc3QgYSBKU09OIHNjaGVtYSBpZiBwcm92aWRlZCAqL1xuICAgIGlmIChzY2hlbWEgJiYgIXRoaXMuanNvblZhbGlkYXRvci52YWxpZGF0ZShkYXRhLCBzY2hlbWEpKSB7XG4gICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgVmFsaWRhdGlvbkVycm9yKCkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRhdGFiYXNlLnNldChrZXksIGRhdGEpLnBpcGUoXG4gICAgICAvKiBDYXRjaCBpZiBgaW5kZXhlZERiYCBpcyBicm9rZW4gKi9cbiAgICAgIHRoaXMuY2F0Y2hJREJCcm9rZW4oKCkgPT4gdGhpcy5kYXRhYmFzZS5zZXQoa2V5LCBkYXRhKSksXG4gICAgICAvKiBOb3RpZnkgd2F0Y2hlcnMgKG11c3QgYmUgbGFzdCBiZWNhdXNlIGl0IHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGUgb3BlcmF0aW9uIHN1Y2NlZWRzKSAqL1xuICAgICAgdGFwKCgpID0+IHsgdGhpcy5ub3RpZnkoa2V5LCBkYXRhKTsgfSksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYW4gaXRlbSBpbiBzdG9yYWdlXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHJldHVybnMgQSBSeEpTIGBPYnNlcnZhYmxlYCB0byB3YWl0IHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvblxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLnN0b3JhZ2VNYXAuZGVsZXRlKCdrZXknKS5zdWJzY3JpYmUoKCkgPT4ge30pO1xuICAgKi9cbiAgZGVsZXRlKGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTx1bmRlZmluZWQ+IHtcblxuICAgIHJldHVybiB0aGlzLmRhdGFiYXNlLmRlbGV0ZShrZXkpLnBpcGUoXG4gICAgICAvKiBDYXRjaCBpZiBgaW5kZXhlZERiYCBpcyBicm9rZW4gKi9cbiAgICAgIHRoaXMuY2F0Y2hJREJCcm9rZW4oKCkgPT4gdGhpcy5kYXRhYmFzZS5kZWxldGUoa2V5KSksXG4gICAgICAvKiBOb3RpZnkgd2F0Y2hlcnMgKG11c3QgYmUgbGFzdCBiZWNhdXNlIGl0IHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGUgb3BlcmF0aW9uIHN1Y2NlZWRzKSAqL1xuICAgICAgdGFwKCgpID0+IHsgdGhpcy5ub3RpZnkoa2V5LCB1bmRlZmluZWQpOyB9KSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGFsbCBpdGVtcyBpbiBzdG9yYWdlXG4gICAqIEByZXR1cm5zIEEgUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5zdG9yYWdlTWFwLmNsZWFyKCkuc3Vic2NyaWJlKCgpID0+IHt9KTtcbiAgICovXG4gIGNsZWFyKCk6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhYmFzZS5jbGVhcigpLnBpcGUoXG4gICAgICAvKiBDYXRjaCBpZiBgaW5kZXhlZERiYCBpcyBicm9rZW4gKi9cbiAgICAgIHRoaXMuY2F0Y2hJREJCcm9rZW4oKCkgPT4gdGhpcy5kYXRhYmFzZS5jbGVhcigpKSxcbiAgICAgIC8qIE5vdGlmeSB3YXRjaGVycyAobXVzdCBiZSBsYXN0IGJlY2F1c2UgaXQgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZSBvcGVyYXRpb24gc3VjY2VlZHMpICovXG4gICAgICB0YXAoKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLm5vdGlmaWVycy5rZXlzKCkpIHtcbiAgICAgICAgICB0aGlzLm5vdGlmeShrZXksIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIGtleXMgc3RvcmVkIGluIHN0b3JhZ2UuIE5vdGUgKip0aGlzIGlzIGFuICppdGVyYXRpbmcqIGBPYnNlcnZhYmxlYCoqOlxuICAgKiAqIGlmIHRoZXJlIGlzIG5vIGtleSwgdGhlIGBuZXh0YCBjYWxsYmFjayB3aWxsIG5vdCBiZSBpbnZva2VkLFxuICAgKiAqIGlmIHlvdSBuZWVkIHRvIHdhaXQgdGhlIHdob2xlIG9wZXJhdGlvbiB0byBlbmQsIGJlIHN1cmUgdG8gYWN0IGluIHRoZSBgY29tcGxldGVgIGNhbGxiYWNrLFxuICAgKiBhcyB0aGlzIGBPYnNlcnZhYmxlYCBjYW4gZW1pdCBzZXZlcmFsIHZhbHVlcyBhbmQgc28gd2lsbCBpbnZva2UgdGhlIGBuZXh0YCBjYWxsYmFjayBzZXZlcmFsIHRpbWVzLlxuICAgKiBAcmV0dXJucyBBIGxpc3Qgb2YgdGhlIGtleXMgd3JhcHBlZCBpbiBhIFJ4SlMgYE9ic2VydmFibGVgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMuc3RvcmFnZU1hcC5rZXlzKCkuc3Vic2NyaWJlKHtcbiAgICogICBuZXh0OiAoa2V5KSA9PiB7IGNvbnNvbGUubG9nKGtleSk7IH0sXG4gICAqICAgY29tcGxldGU6ICgpID0+IHsgY29uc29sZS5sb2coJ0RvbmUnKTsgfSxcbiAgICogfSk7XG4gICAqL1xuICBrZXlzKCk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhYmFzZS5rZXlzKClcbiAgICAgIC8qIENhdGNoIGlmIGBpbmRleGVkRGJgIGlzIGJyb2tlbiAqL1xuICAgICAgLnBpcGUodGhpcy5jYXRjaElEQkJyb2tlbigoKSA9PiB0aGlzLmRhdGFiYXNlLmtleXMoKSkpO1xuXG4gIH1cblxuICAvKipcbiAgICogVGVsbHMgaWYgYSBrZXkgZXhpc3RzIGluIHN0b3JhZ2VcbiAgICogQHJldHVybnMgQSBSeEpTIGBPYnNlcnZhYmxlYCB0ZWxsaW5nIGlmIHRoZSBrZXkgZXhpc3RzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMuc3RvcmFnZU1hcC5oYXMoJ2tleScpLnN1YnNjcmliZSgoaGFzS2V5KSA9PiB7XG4gICAqICAgaWYgKGhhc0tleSkge31cbiAgICogfSk7XG4gICAqL1xuICBoYXMoa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcblxuICAgIHJldHVybiB0aGlzLmRhdGFiYXNlLmhhcyhrZXkpXG4gICAgICAvKiBDYXRjaCBpZiBgaW5kZXhlZERiYCBpcyBicm9rZW4gKi9cbiAgICAgIC5waXBlKHRoaXMuY2F0Y2hJREJCcm9rZW4oKCkgPT4gdGhpcy5kYXRhYmFzZS5oYXMoa2V5KSkpO1xuXG4gIH1cblxuICAvKipcbiAgICogV2F0Y2ggYW4gaXRlbSB2YWx1ZSBpbiBzdG9yYWdlLlxuICAgKiAqKk5vdGUgb25seSBjaGFuZ2VzIGRvbmUgdmlhIHRoaXMgbGliIHdpbGwgYmUgd2F0Y2hlZCoqLCBleHRlcm5hbCBjaGFuZ2VzIGluIHN0b3JhZ2UgY2FuJ3QgYmUgZGV0ZWN0ZWQuXG4gICAqIFRoZSBzaWduYXR1cmUgaGFzIG1hbnkgb3ZlcmxvYWRzIGR1ZSB0byB2YWxpZGF0aW9uLCAqKnBsZWFzZSByZWZlciB0byB0aGUgZG9jdW1lbnRhdGlvbi4qKlxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYWluL2RvY3MvVkFMSURBVElPTi5tZFxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5IHRvIHdhdGNoXG4gICAqIEBwYXJhbSBzY2hlbWEgT3B0aW9uYWwgSlNPTiBzY2hlbWEgdG8gdmFsaWRhdGUgdGhlIGluaXRpYWwgdmFsdWVcbiAgICogQHJldHVybnMgQW4gaW5maW5pdGUgYE9ic2VydmFibGVgIGdpdmluZyB0aGUgY3VycmVudCB2YWx1ZVxuICAgKi9cbiAgd2F0Y2goa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPHVua25vd24+O1xuICB3YXRjaDxUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hU3RyaW5nKTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgd2F0Y2g8VCBleHRlbmRzIG51bWJlciA9IG51bWJlcj4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUludGVnZXIgfCBKU09OU2NoZW1hTnVtYmVyKTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgd2F0Y2g8VCBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQm9vbGVhbik6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIHdhdGNoPFQgZXh0ZW5kcyByZWFkb25seSBzdHJpbmdbXSA9IHN0cmluZ1tdPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXlPZjxKU09OU2NoZW1hU3RyaW5nPik6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIHdhdGNoPFQgZXh0ZW5kcyByZWFkb25seSBudW1iZXJbXSA9IG51bWJlcltdPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXlPZjxKU09OU2NoZW1hSW50ZWdlciB8IEpTT05TY2hlbWFOdW1iZXI+KTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgd2F0Y2g8VCBleHRlbmRzIHJlYWRvbmx5IGJvb2xlYW5bXSA9IGJvb2xlYW5bXT4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUFycmF5T2Y8SlNPTlNjaGVtYUJvb2xlYW4+KTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBjYXN0IGlzIHVzZWxlc3MgaGVyZSBhbmQgZG9lc24ndCBtYXRjaCB0aGUgSlNPTiBzY2hlbWEuIEp1c3QgcmVtb3ZlIHRoZSBjYXN0LlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2Jsb2IvbWFpbi9kb2NzL1ZBTElEQVRJT04ubWR9XG4gICAqL1xuICB3YXRjaDxUID0gc3RyaW5nPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hU3RyaW5nKTogT2JzZXJ2YWJsZTxzdHJpbmcgfCB1bmRlZmluZWQ+O1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVGhlIGNhc3QgaXMgdXNlbGVzcyBoZXJlIGFuZCBkb2Vzbid0IG1hdGNoIHRoZSBKU09OIHNjaGVtYS4gSnVzdCByZW1vdmUgdGhlIGNhc3QuXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYWluL2RvY3MvVkFMSURBVElPTi5tZH1cbiAgICovXG4gIHdhdGNoPFQgPSBudW1iZXI+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFJbnRlZ2VyIHwgSlNPTlNjaGVtYU51bWJlcik6IE9ic2VydmFibGU8bnVtYmVyIHwgdW5kZWZpbmVkPjtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBjYXN0IGlzIHVzZWxlc3MgaGVyZSBhbmQgZG9lc24ndCBtYXRjaCB0aGUgSlNPTiBzY2hlbWEuIEp1c3QgcmVtb3ZlIHRoZSBjYXN0LlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2Jsb2IvbWFpbi9kb2NzL1ZBTElEQVRJT04ubWR9XG4gICAqL1xuICB3YXRjaDxUID0gYm9vbGVhbj4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUJvb2xlYW4pOiBPYnNlcnZhYmxlPGJvb2xlYW4gfCB1bmRlZmluZWQ+O1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVGhlIGNhc3QgaXMgdXNlbGVzcyBoZXJlIGFuZCBkb2Vzbid0IG1hdGNoIHRoZSBKU09OIHNjaGVtYS4gSnVzdCByZW1vdmUgdGhlIGNhc3QuXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYWluL2RvY3MvVkFMSURBVElPTi5tZH1cbiAgICovXG4gIHdhdGNoPFQgPSBzdHJpbmdbXT4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUFycmF5T2Y8SlNPTlNjaGVtYVN0cmluZz4pOiBPYnNlcnZhYmxlPHN0cmluZ1tdIHwgdW5kZWZpbmVkPjtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBjYXN0IGlzIHVzZWxlc3MgaGVyZSBhbmQgZG9lc24ndCBtYXRjaCB0aGUgSlNPTiBzY2hlbWEuIEp1c3QgcmVtb3ZlIHRoZSBjYXN0LlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2Jsb2IvbWFpbi9kb2NzL1ZBTElEQVRJT04ubWR9XG4gICAqL1xuICB3YXRjaDxUID0gbnVtYmVyW10+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFBcnJheU9mPEpTT05TY2hlbWFJbnRlZ2VyIHwgSlNPTlNjaGVtYU51bWJlcj4pOiBPYnNlcnZhYmxlPG51bWJlcltdIHwgdW5kZWZpbmVkPjtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoZSBjYXN0IGlzIHVzZWxlc3MgaGVyZSBhbmQgZG9lc24ndCBtYXRjaCB0aGUgSlNPTiBzY2hlbWEuIEp1c3QgcmVtb3ZlIHRoZSBjYXN0LlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2Jsb2IvbWFpbi9kb2NzL1ZBTElEQVRJT04ubWR9XG4gICAqL1xuICB3YXRjaDxUID0gYm9vbGVhbltdPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXlPZjxKU09OU2NoZW1hQm9vbGVhbj4pOiBPYnNlcnZhYmxlPGJvb2xlYW5bXSB8IHVuZGVmaW5lZD47XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBBIGNhc3QgaXMgcmVxdWlyZWQgaGVyZSwgb3RoZXJ3aXNlIHRoZSByZXR1cm4gd2lsbCBiZSBgdW5rbm93bmAgZGVzcGl0ZSBhIEpTT04gc2NoZW1hIHdhcyBwcm92aWRlZC5cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9ibG9iL21haW4vZG9jcy9WQUxJREFUSU9OLm1kfVxuICAgKi9cbiAgd2F0Y2goa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYSk6IE9ic2VydmFibGU8dW5rbm93biB8IHVuZGVmaW5lZD47XG4gIHdhdGNoPFQ+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWEpOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+O1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVGhlIGNhc3QgaXMgdXNlbGVzcyBoZXJlOiBhcyBubyBKU09OIHNjaGVtYSB3YXMgcHJvdmlkZWQgZm9yIHZhbGlkYXRpb24sIHRoZSByZXN1bHQgd2lsbCBzdGlsbCBiZSBgdW5rbm93bmAuXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYWluL2RvY3MvVkFMSURBVElPTi5tZH1cbiAgICovXG4gIHdhdGNoPFQ+KGtleTogc3RyaW5nLCBzY2hlbWE/OiBKU09OU2NoZW1hKTogT2JzZXJ2YWJsZTx1bmtub3duPjtcbiAgd2F0Y2g8VCA9IHVua25vd24+KGtleTogc3RyaW5nLCBzY2hlbWE/OiBKU09OU2NoZW1hKTogT2JzZXJ2YWJsZTx1bmtub3duPiB7XG5cbiAgICAvKiBDaGVjayBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgbm90aWZpZXIgKi9cbiAgICBpZiAoIXRoaXMubm90aWZpZXJzLmhhcyhrZXkpKSB7XG4gICAgICB0aGlzLm5vdGlmaWVycy5zZXQoa2V5LCBuZXcgUmVwbGF5U3ViamVjdCgxKSk7XG4gICAgfVxuXG4gICAgLyogTm9uLW51bGwgYXNzZXJ0aW9uIGlzIHJlcXVpcmVkIGJlY2F1c2UgVHlwZVNjcmlwdCBkb2Vzbid0IG5hcnJvdyBgLmhhcygpYCB5ZXQgKi9cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIGNvbnN0IG5vdGlmaWVyID0gdGhpcy5ub3RpZmllcnMuZ2V0KGtleSkhO1xuXG4gICAgLyogR2V0IHRoZSBjdXJyZW50IGl0ZW0gdmFsdWUgKi9cbiAgICAoc2NoZW1hID8gdGhpcy5nZXQ8VD4oa2V5LCBzY2hlbWEpIDogdGhpcy5nZXQoa2V5KSkuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6IChyZXN1bHQpID0+IG5vdGlmaWVyLm5leHQocmVzdWx0KSxcbiAgICAgIGVycm9yOiAoZXJyb3IpID0+IG5vdGlmaWVyLmVycm9yKGVycm9yKSxcbiAgICB9KTtcblxuICAgIC8qIE9ubHkgdGhlIHB1YmxpYyBBUEkgb2YgdGhlIGBPYnNlcnZhYmxlYCBzaG91bGQgYmUgcmV0dXJuZWQgKi9cbiAgICByZXR1cm4gKHNjaGVtYSA/XG4gICAgICBub3RpZmllci5hc09ic2VydmFibGUoKSBhcyBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+IDpcbiAgICAgIG5vdGlmaWVyLmFzT2JzZXJ2YWJsZSgpXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmeSB3aGVuIGEgdmFsdWUgY2hhbmdlc1xuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEBwYXJhbSBkYXRhIFRoZSBuZXcgdmFsdWVcbiAgICovXG4gIHByb3RlY3RlZCBub3RpZnkoa2V5OiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdm9pZCB7XG5cbiAgICBjb25zdCBub3RpZmllciA9IHRoaXMubm90aWZpZXJzLmdldChrZXkpO1xuXG4gICAgaWYgKG5vdGlmaWVyKSB7XG4gICAgICBub3RpZmllci5uZXh0KHZhbHVlKTtcbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBSeEpTIG9wZXJhdG9yIHRvIGNhdGNoIGlmIGBpbmRleGVkREJgIGlzIGJyb2tlblxuICAgKiBAcGFyYW0gb3BlcmF0aW9uQ2FsbGJhY2sgQ2FsbGJhY2sgd2l0aCB0aGUgb3BlcmF0aW9uIHRvIHJlZG9cbiAgICovXG4gIHByb3RlY3RlZCBjYXRjaElEQkJyb2tlbjxUPihvcGVyYXRpb25DYWxsYmFjazogKCkgPT4gT2JzZXJ2YWJsZTxUPik6IE9wZXJhdG9yRnVuY3Rpb248VCwgVD4ge1xuXG4gICAgcmV0dXJuIGNhdGNoRXJyb3IoKGVycm9yKSA9PiB7XG5cbiAgICAgIC8qIENoZWNrIGlmIGBpbmRleGVkREJgIGlzIGJyb2tlbiBiYXNlZCBvbiBlcnJvciBtZXNzYWdlICh0aGUgc3BlY2lmaWMgZXJyb3IgY2xhc3Mgc2VlbXMgdG8gYmUgbG9zdCBpbiB0aGUgcHJvY2VzcykgKi9cbiAgICAgIGlmICgoZXJyb3IgIT09IHVuZGVmaW5lZCkgJiYgKGVycm9yICE9PSBudWxsKSAmJiAoZXJyb3IubWVzc2FnZSA9PT0gSURCX0JST0tFTl9FUlJPUikpIHtcblxuICAgICAgICAvKiBXaGVuIHN0b3JhZ2UgaXMgZnVsbHkgZGlzYWJsZWQgaW4gYnJvd3NlciAodmlhIHRoZSBcIkJsb2NrIGFsbCBjb29raWVzXCIgb3B0aW9uKSxcbiAgICAgICAgICoganVzdCB0cnlpbmcgdG8gY2hlY2sgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgY2F1c2VzIGEgc2VjdXJpdHkgZXhjZXB0aW9uLlxuICAgICAgICAgKiBQcmV2ZW50cyBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2lzc3Vlcy8xMThcbiAgICAgICAgICovXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICBpZiAoJ2dldEl0ZW0nIGluIGxvY2FsU3RvcmFnZSkge1xuXG4gICAgICAgICAgICAvKiBGYWxsYmFjayB0byBgbG9jYWxTdG9yYWdlYCBpZiBhdmFpbGFibGUgKi9cbiAgICAgICAgICAgIHRoaXMuZGF0YWJhc2UgPSBuZXcgTG9jYWxTdG9yYWdlRGF0YWJhc2UodGhpcy5MU1ByZWZpeCk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvKiBGYWxsYmFjayB0byBtZW1vcnkgc3RvcmFnZSBvdGhlcndpc2UgKi9cbiAgICAgICAgICAgIHRoaXMuZGF0YWJhc2UgPSBuZXcgTWVtb3J5RGF0YWJhc2UoKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9IGNhdGNoIHtcblxuICAgICAgICAgIC8qIEZhbGxiYWNrIHRvIG1lbW9yeSBzdG9yYWdlIG90aGVyd2lzZSAqL1xuICAgICAgICAgIHRoaXMuZGF0YWJhc2UgPSBuZXcgTWVtb3J5RGF0YWJhc2UoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLyogUmVkbyB0aGUgb3BlcmF0aW9uICovXG4gICAgICAgIHJldHVybiBvcGVyYXRpb25DYWxsYmFjaygpO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8qIE90aGVyd2lzZSwgcmV0aHJvdyB0aGUgZXJyb3IgKi9cbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoZXJyb3IpO1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbn1cbiJdfQ==