import { Injectable, Inject } from '@angular/core';
import { ReplaySubject, fromEvent, of, throwError, race } from 'rxjs';
import { map, mergeMap, first, takeWhile, tap, mapTo } from 'rxjs/operators';
import { IDB_DB_NAME, IDB_STORE_NAME, DEFAULT_IDB_STORE_NAME, IDB_DB_VERSION, DEFAULT_IDB_DB_NAME, DEFAULT_IDB_DB_VERSION, IDB_NO_WRAP, DEFAULT_IDB_NO_WRAP } from '../tokens';
import { IDBBrokenError } from './exceptions';
import * as i0 from "@angular/core";
import * as i1 from "../tokens";
export class IndexedDBDatabase {
    /**
     * Constructor params are provided by Angular (but can also be passed manually in tests)
     * @param dbName `indexedDB` database name
     * @param storeName `indexedDB` store name
     * @param dbVersion `indexedDB` database version
     * @param noWrap Flag to not wrap `indexedDB` values for interoperability or to wrap for backward compatibility
     */
    constructor(dbName = DEFAULT_IDB_DB_NAME, storeName = DEFAULT_IDB_STORE_NAME, dbVersion = DEFAULT_IDB_DB_VERSION, noWrap = DEFAULT_IDB_NO_WRAP) {
        /**
         * `indexedDB` database connection, wrapped in a RxJS `ReplaySubject` to be able to access the connection
         * even after the connection success event happened
         */
        this.database = new ReplaySubject(1);
        /**
         * Index used when wrapping value. *For backward compatibility only.*
         */
        this.wrapIndex = 'value';
        this.dbName = dbName;
        this.storeName = storeName;
        this.dbVersion = dbVersion;
        this.noWrap = noWrap;
        /* Connect to `indexedDB`, with prefix if provided by the user */
        this.connect();
    }
    /**
     * Information about `indexedDB` connection. *Only useful for interoperability.*
     * @returns `indexedDB` database name, store name and database version
     */
    get backingStore() {
        return {
            database: this.dbName,
            store: this.storeName,
            version: this.dbVersion,
        };
    }
    /**
     * Number of items in our `indexedDB` database and object store
     */
    get size() {
        /* Open a transaction in read-only mode */
        return this.transaction('readonly').pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Request to know the number of items */
            const request = store.count();
            /* Return the result */
            return events.pipe(map(() => request.result));
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Gets an item value in our `indexedDB` store
     * @param key The item's key
     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in an RxJS `Observable`
     */
    get(key) {
        /* Open a transaction in read-only mode */
        return this.transaction('readonly').pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Request the value with the key provided by the user */
            const request = store.get(key);
            /* Listen events and return the result */
            return events.pipe(map(() => {
                if ((request.result !== undefined) && (request.result !== null)) {
                    /* Prior to v8, the value was wrapped in an `{ value: ...}` object */
                    if (!this.noWrap && (typeof request.result === 'object') && (this.wrapIndex in request.result) &&
                        (request.result[this.wrapIndex] !== undefined) && (request.result[this.wrapIndex] !== null)) {
                        return request.result[this.wrapIndex];
                    }
                    else {
                        /* Cast to the wanted type */
                        return request.result;
                    }
                }
                /* Return `undefined` if the value is empty */
                return undefined;
            }));
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Sets an item in our `indexedDB` store
     * @param key The item's key
     * @param data The item's value
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    set(key, data) {
        /* Storing `undefined` in `indexedDb` can cause issues in some browsers so removing item instead */
        if (data === undefined) {
            return this.delete(key);
        }
        /* Open a transaction in write mode */
        return this.transaction('readwrite').pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Prior to v8, data was wrapped in a `{ value: ... }` object */
            const dataToStore = this.noWrap ? data : { [this.wrapIndex]: data };
            /* Add if the item is not existing yet, or update otherwise */
            store.put(dataToStore, key);
            /* Listen to events and return `undefined` as no value is expected */
            return events.pipe(mapTo(undefined));
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Deletes an item in our `indexedDB` store
     * @param key The item's key
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    delete(key) {
        /* Open a transaction in write mode */
        return this.transaction('readwrite').pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Delete the item in store */
            store.delete(key);
            /* Listen to events and return `undefined` as no data is expected here */
            return events.pipe(mapTo(undefined));
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Deletes all items from our `indexedDB` objet store
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    clear() {
        /* Open a transaction in write mode */
        return this.transaction('readwrite').pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Delete all items in object store */
            store.clear();
            /* Listen to events and return `undefined` as no data is expected here */
            return events.pipe(mapTo(undefined));
        }), 
        /* The observable will complete */
        first());
    }
    /**
     * Get all the keys in our `indexedDB` store
     * @returns An RxJS `Observable` iterating on each key
     */
    keys() {
        /* Open a transaction in read-only mode */
        return this.transaction('readonly').pipe(
        /* `first()` is used as the final operator in other methods to complete the `Observable`
         * (as it all starts from a `ReplaySubject` which never ends),
         * but as this method is iterating over multiple values, `first()` **must** be used here */
        first(), mergeMap((transactionData) => {
            const { store } = transactionData;
            /* Open a cursor on the store
             * `.openKeyCursor()` is better for performance, but only available in indexedDB v2 (missing in IE)
             * Avoid issues like https://github.com/cyrilletuzi/angular-async-local-storage/issues/69 */
            const request = ('openKeyCursor' in store) ? store.openKeyCursor() : store.openCursor();
            /* Listen to success event */
            const success$ = fromEvent(request, 'success').pipe(
            /* Stop the `Observable` when the cursor is `null` */
            takeWhile(() => (request.result !== null)), 
            /* This lib only allows string keys, but user could have added other types of keys from outside
             * It's OK to cast as the cursor as been tested in the previous operator */
            map(() => request.result.key.toString()), 
            /* Iterate on the cursor */
            tap(() => { request.result.continue(); }));
            /* Listen to error event and if so, throw an error */
            const error$ = this.listenError(request);
            /* Choose the first event to occur */
            return race([success$, error$]);
        }));
    }
    /**
     * Check if a key exists in our `indexedDB` store
     * @returns An RxJS `Observable` telling if the key exists or not
     */
    has(key) {
        /* Open a transaction in read-only mode */
        return this.transaction('readonly').pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Check if the key exists in the store
             * `getKey()` is better but only available in `indexedDB` v2 (Chrome >= 58, missing in IE/Edge Legacy).
             * In older browsers, the value is checked instead, but it could lead to an exception
             * if `undefined` was stored outside of this lib (e.g. directly with the native `indexedDB` API).
             * Fixes https://github.com/cyrilletuzi/angular-async-local-storage/issues/69
             */
            const request = ('getKey' in store) ? store.getKey(key) : store.get(key);
            /* Listen to events and return `true` or `false` */
            return events.pipe(map(() => (request.result !== undefined) ? true : false));
        }), 
        /* The observable will complete */
        first());
    }
    /**
     * Connects to `indexedDB` and creates the object store on first time
     */
    connect() {
        let request;
        /* Connect to `indexedDB`
         * Will fail in Safari cross-origin iframes
         * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42} */
        try {
            /* Do NOT explicit `window` here, as `indexedDB` could be used from a web worker too */
            request = indexedDB.open(this.dbName, this.dbVersion);
        }
        catch (_a) {
            this.database.error(new IDBBrokenError());
            return;
        }
        /* Create store on first connection */
        this.createStore(request);
        /* Listen to success and error events */
        const success$ = fromEvent(request, 'success');
        const error$ = this.listenError(request);
        /* Choose the first to occur */
        race([success$, error$])
            /* The observable will complete */
            .pipe(first())
            .subscribe({
            next: () => {
                /* Register the database connection in the `ReplaySubject` for further access */
                this.database.next(request.result);
            },
            error: () => {
                /* Firefox private mode issue: fallback storage if IndexedDb connection is failing
                * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}
                * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/26} */
                this.database.error(new IDBBrokenError());
            },
        });
    }
    /**
     * Create store on first use of `indexedDB`
     * @param request `indexedDB` database opening request
     */
    createStore(request) {
        /* Listen to the event fired on first connection */
        fromEvent(request, 'upgradeneeded')
            /* The observable will complete */
            .pipe(first())
            .subscribe({
            next: () => {
                /* Check if the store already exists, to avoid error */
                if (!request.result.objectStoreNames.contains(this.storeName)) {
                    /* Create the object store */
                    request.result.createObjectStore(this.storeName);
                }
            }
        });
    }
    /**
     * Open an `indexedDB` transaction and get our store
     * @param mode `readonly` or `readwrite`
     * @returns An `indexedDB` transaction store and events, wrapped in an RxJS `Observable`
     */
    transaction(mode) {
        /* From the `indexedDB` connection, open a transaction and get the store */
        return this.database
            .pipe(mergeMap((database) => {
            let transaction;
            try {
                transaction = database.transaction([this.storeName], mode);
            }
            catch (error) {
                /* The store could have been deleted from outside */
                return throwError(error);
            }
            /* Get the store from the transaction */
            const store = transaction.objectStore(this.storeName);
            /* Listen transaction `complete` and `error` events */
            const events = this.listenTransactionEvents(transaction);
            return of({ store, events });
        }));
    }
    /**
     * Listen errors on a transaction or request, and throw if trigerred
     * @param transactionOrRequest `indexedDb` transaction or request to listen
     * @returns An `Observable` listening to errors
     */
    listenError(transactionOrRequest) {
        return fromEvent(transactionOrRequest, 'error').pipe(
        /* Throw on error to be able to catch errors in RxJS way.
         * Here `event.target` must be used, as `transactionOrRequest.error` will be `null`
         * if we are on the request and the error is only triggered later by the transaction */
        mergeMap((event) => throwError(event.target.error)));
    }
    /**
     * Listen transaction `complete` and `error` events
     * @param transaction Transaction to listen
     * @returns An `Observable` listening to transaction `complete` and `error` events
     */
    listenTransactionEvents(transaction) {
        /* Listen to the `complete` event */
        const complete$ = fromEvent(transaction, 'complete');
        /* Listen to the `error` event */
        const error$ = this.listenError(transaction);
        /* Choose the first event to occur */
        return race([complete$, error$]);
    }
}
IndexedDBDatabase.ɵprov = i0.ɵɵdefineInjectable({ factory: function IndexedDBDatabase_Factory() { return new IndexedDBDatabase(i0.ɵɵinject(i1.IDB_DB_NAME), i0.ɵɵinject(i1.IDB_STORE_NAME), i0.ɵɵinject(i1.IDB_DB_VERSION), i0.ɵɵinject(i1.IDB_NO_WRAP)); }, token: IndexedDBDatabase, providedIn: "root" });
IndexedDBDatabase.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
IndexedDBDatabase.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [IDB_DB_NAME,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [IDB_STORE_NAME,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [IDB_DB_VERSION,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [IDB_NO_WRAP,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXhlZGRiLWRhdGFiYXNlLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1wd2EvbG9jYWwtc3RvcmFnZS9zcmMvIiwic291cmNlcyI6WyJsaWIvZGF0YWJhc2VzL2luZGV4ZWRkYi1kYXRhYmFzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQWMsYUFBYSxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNsRixPQUFPLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUU3RSxPQUFPLEVBQ0wsV0FBVyxFQUFFLGNBQWMsRUFBRSxzQkFBc0IsRUFBRSxjQUFjLEVBQ25FLG1CQUFtQixFQUFFLHNCQUFzQixFQUFFLFdBQVcsRUFBRSxtQkFBbUIsRUFDOUUsTUFBTSxXQUFXLENBQUM7QUFDbkIsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGNBQWMsQ0FBQzs7O0FBTTlDLE1BQU0sT0FBTyxpQkFBaUI7SUFpQzVCOzs7Ozs7T0FNRztJQUNILFlBQ3VCLE1BQU0sR0FBRyxtQkFBbUIsRUFDekIsU0FBUyxHQUFHLHNCQUFzQixFQUNsQyxTQUFTLEdBQUcsc0JBQXNCLEVBQ3JDLE1BQU0sR0FBRyxtQkFBbUI7UUEzQm5EOzs7V0FHRztRQUNnQixhQUFRLEdBQUcsSUFBSSxhQUFhLENBQWMsQ0FBQyxDQUFDLENBQUM7UUFPaEU7O1dBRUc7UUFDZ0IsY0FBUyxHQUFHLE9BQU8sQ0FBQztRQWdCckMsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7UUFDM0IsSUFBSSxDQUFDLFNBQVMs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RUosQ0FBQztJQUVEOzs7O09BSUc7SUFDTyx1QkFBdUIsQ0FBQyxXQUEyQjtRQUUzRCxvQ0FBb0M7UUFDcEMsTUFBTSxTQUFTLEdBQUcsU0FBUyxDQUFDLFdBQVcsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUVyRCxpQ0FBaUM7UUFDakMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUU3QyxxQ0FBcUM7UUFDckMsT0FBTyxJQUFJLENBQUMsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUVuQyxDQUFDOzs7O1lBbmNGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7OzRDQTBDSSxNQUFNLFNBQUMsV0FBVzs0Q0FDbEIsTUFBTSxTQUFDLGNBQWM7NENBQ3JCLE1BQU0sU0FBQyxjQUFjOzRDQUNyQixNQUFNLFNBQUMsV0FBVyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgUmVwbGF5U3ViamVjdCwgZnJvbUV2ZW50LCBvZiwgdGhyb3dFcnJvciwgcmFjZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwLCBtZXJnZU1hcCwgZmlyc3QsIHRha2VXaGlsZSwgdGFwLCBtYXBUbyB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHtcbiAgSURCX0RCX05BTUUsIElEQl9TVE9SRV9OQU1FLCBERUZBVUxUX0lEQl9TVE9SRV9OQU1FLCBJREJfREJfVkVSU0lPTixcbiAgREVGQVVMVF9JREJfREJfTkFNRSwgREVGQVVMVF9JREJfREJfVkVSU0lPTiwgSURCX05PX1dSQVAsIERFRkFVTFRfSURCX05PX1dSQVBcbn0gZnJvbSAnLi4vdG9rZW5zJztcbmltcG9ydCB7IElEQkJyb2tlbkVycm9yIH0gZnJvbSAnLi9leGNlcHRpb25zJztcbmltcG9ydCB7IExvY2FsRGF0YWJhc2UgfSBmcm9tICcuL2xvY2FsLWRhdGFiYXNlJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgSW5kZXhlZERCRGF0YWJhc2UgaW1wbGVtZW50cyBMb2NhbERhdGFiYXNlIHtcblxuICAvKipcbiAgICogYGluZGV4ZWREQmAgZGF0YWJhc2UgbmFtZVxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGRiTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBgaW5kZXhlZERCYCBvYmplY3Qgc3RvcmUgbmFtZVxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHN0b3JlTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBgaW5kZXhlZERCYCBkYXRhYmFzZSB2ZXJzaW9uLiBNdXN0IGJlIGFuIHVuc2lnbmVkICoqaW50ZWdlcioqXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGJWZXJzaW9uOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIGBpbmRleGVkREJgIGRhdGFiYXNlIGNvbm5lY3Rpb24sIHdyYXBwZWQgaW4gYSBSeEpTIGBSZXBsYXlTdWJqZWN0YCB0byBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgY29ubmVjdGlvblxuICAgKiBldmVuIGFmdGVyIHRoZSBjb25uZWN0aW9uIHN1Y2Nlc3MgZXZlbnQgaGFwcGVuZWRcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBkYXRhYmFzZSA9IG5ldyBSZXBsYXlTdWJqZWN0PElEQkRhdGFiYXNlPigxKTtcblxuICAvKipcbiAgICogRmxhZyB0byBub3Qgd3JhcCBgaW5kZXhlZERCYCB2YWx1ZXMgZm9yIGludGVyb3BlcmFiaWxpdHkgb3IgdG8gd3JhcCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBub1dyYXA6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEluZGV4IHVzZWQgd2hlbiB3cmFwcGluZyB2YWx1ZS4gKkZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IG9ubHkuKlxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHdyYXBJbmRleCA9ICd2YWx1ZSc7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIHBhcmFtcyBhcmUgcHJvdmlkZWQgYnkgQW5ndWxhciAoYnV0IGNhbiBhbHNvIGJlIHBhc3NlZCBtYW51YWxseSBpbiB0ZXN0cylcbiAgICogQHBhcmFtIGRiTmFtZSBgaW5kZXhlZERCYCBkYXRhYmFzZSBuYW1lXG4gICAqIEBwYXJhbSBzdG9yZU5hbWUgYGluZGV4ZWREQmAgc3RvcmUgbmFtZVxuICAgKiBAcGFyYW0gZGJWZXJzaW9uIGBpbmRleGVkREJgIGRhdGFiYXNlIHZlcnNpb25cbiAgICogQHBhcmFtIG5vV3JhcCBGbGFnIHRvIG5vdCB3cmFwIGBpbmRleGVkREJgIHZhbHVlcyBmb3IgaW50ZXJvcGVyYWJpbGl0eSBvciB0byB3cmFwIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KElEQl9EQl9OQU1FKSBkYk5hbWUgPSBERUZBVUxUX0lEQl9EQl9OQU1FLFxuICAgIEBJbmplY3QoSURCX1NUT1JFX05BTUUpIHN0b3JlTmFtZSA9IERFRkFVTFRfSURCX1NUT1JFX05BTUUsXG4gICAgQEluamVjdChJREJfREJfVkVSU0lPTikgZGJWZXJzaW9uID0gREVGQVVMVF9JREJfREJfVkVSU0lPTixcbiAgICBASW5qZWN0KElEQl9OT19XUkFQKSBub1dyYXAgPSBERUZBVUxUX0lEQl9OT19XUkFQLFxuICApIHtcblxuICAgIHRoaXMuZGJOYW1lID0gZGJOYW1lO1xuICAgIHRoaXMuc3RvcmVOYW1lID0gc3RvcmVOYW1lO1xuICAgIHRoaXMuZGJWZXJzaW9uID0gZGJWZXJzaW9uO1xuICAgIHRoaXMubm9XcmFwID0gbm9XcmFwO1xuXG4gICAgLyogQ29ubmVjdCB0byBgaW5kZXhlZERCYCwgd2l0aCBwcmVmaXggaWYgcHJvdmlkZWQgYnkgdGhlIHVzZXIgKi9cbiAgICB0aGlzLmNvbm5lY3QoKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEluZm9ybWF0aW9uIGFib3V0IGBpbmRleGVkREJgIGNvbm5lY3Rpb24uICpPbmx5IHVzZWZ1bCBmb3IgaW50ZXJvcGVyYWJpbGl0eS4qXG4gICAqIEByZXR1cm5zIGBpbmRleGVkREJgIGRhdGFiYXNlIG5hbWUsIHN0b3JlIG5hbWUgYW5kIGRhdGFiYXNlIHZlcnNpb25cbiAgICovXG4gIGdldCBiYWNraW5nU3RvcmUoKTogeyBkYXRhYmFzZTogc3RyaW5nLCBzdG9yZTogc3RyaW5nLCB2ZXJzaW9uOiBudW1iZXIgfSB7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YWJhc2U6IHRoaXMuZGJOYW1lLFxuICAgICAgc3RvcmU6IHRoaXMuc3RvcmVOYW1lLFxuICAgICAgdmVyc2lvbjogdGhpcy5kYlZlcnNpb24sXG4gICAgfTtcblxuICB9XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBpdGVtcyBpbiBvdXIgYGluZGV4ZWREQmAgZGF0YWJhc2UgYW5kIG9iamVjdCBzdG9yZVxuICAgKi9cbiAgZ2V0IHNpemUoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcblxuICAgIC8qIE9wZW4gYSB0cmFuc2FjdGlvbiBpbiByZWFkLW9ubHkgbW9kZSAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKCdyZWFkb25seScpLnBpcGUoXG4gICAgICBtZXJnZU1hcCgodHJhbnNhY3Rpb25EYXRhKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdG9yZSwgZXZlbnRzIH0gPSB0cmFuc2FjdGlvbkRhdGE7XG5cbiAgICAgICAgLyogUmVxdWVzdCB0byBrbm93IHRoZSBudW1iZXIgb2YgaXRlbXMgKi9cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmNvdW50KCk7XG5cbiAgICAgICAgLyogUmV0dXJuIHRoZSByZXN1bHQgKi9cbiAgICAgICAgcmV0dXJuIGV2ZW50cy5waXBlKG1hcCgoKSA9PiByZXF1ZXN0LnJlc3VsdCkpO1xuXG4gICAgICB9KSxcbiAgICAgIC8qIFRoZSBvYnNlcnZhYmxlIHdpbGwgY29tcGxldGUgYWZ0ZXIgdGhlIGZpcnN0IHZhbHVlICovXG4gICAgICBmaXJzdCgpLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGl0ZW0gdmFsdWUgaW4gb3VyIGBpbmRleGVkREJgIHN0b3JlXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHJldHVybnMgVGhlIGl0ZW0ncyB2YWx1ZSBpZiB0aGUga2V5IGV4aXN0cywgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLCB3cmFwcGVkIGluIGFuIFJ4SlMgYE9ic2VydmFibGVgXG4gICAqL1xuICBnZXQoa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPHVua25vd27CoHwgdW5kZWZpbmVkPiB7XG5cbiAgICAvKiBPcGVuIGEgdHJhbnNhY3Rpb24gaW4gcmVhZC1vbmx5IG1vZGUgKi9cbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbigncmVhZG9ubHknKS5waXBlKFxuICAgICAgbWVyZ2VNYXAoKHRyYW5zYWN0aW9uRGF0YSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RvcmUsIGV2ZW50cyB9ID0gdHJhbnNhY3Rpb25EYXRhO1xuXG4gICAgICAgIC8qIFJlcXVlc3QgdGhlIHZhbHVlIHdpdGggdGhlIGtleSBwcm92aWRlZCBieSB0aGUgdXNlciAqL1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0KGtleSk7XG5cbiAgICAgICAgLyogTGlzdGVuIGV2ZW50cyBhbmQgcmV0dXJuIHRoZSByZXN1bHQgKi9cbiAgICAgICAgcmV0dXJuIGV2ZW50cy5waXBlKG1hcCgoKSA9PiB7XG5cbiAgICAgICAgICBpZiAoKHJlcXVlc3QucmVzdWx0ICE9PSB1bmRlZmluZWQpICYmIChyZXF1ZXN0LnJlc3VsdCAhPT0gbnVsbCkpIHtcblxuICAgICAgICAgICAgLyogUHJpb3IgdG8gdjgsIHRoZSB2YWx1ZSB3YXMgd3JhcHBlZCBpbiBhbiBgeyB2YWx1ZTogLi4ufWAgb2JqZWN0ICovXG4gICAgICAgICAgICBpZiAoIXRoaXMubm9XcmFwICYmICh0eXBlb2YgcmVxdWVzdC5yZXN1bHQgPT09ICdvYmplY3QnKSAmJiAodGhpcy53cmFwSW5kZXggaW4gcmVxdWVzdC5yZXN1bHQpICYmXG4gICAgICAgICAgICAocmVxdWVzdC5yZXN1bHRbdGhpcy53cmFwSW5kZXhdICE9PSB1bmRlZmluZWQpICYmIChyZXF1ZXN0LnJlc3VsdFt0aGlzLndyYXBJbmRleF0gIT09IG51bGwpKSB7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QucmVzdWx0W3RoaXMud3JhcEluZGV4XTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAvKiBDYXN0IHRvIHRoZSB3YW50ZWQgdHlwZSAqL1xuICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdC5yZXN1bHQ7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qIFJldHVybiBgdW5kZWZpbmVkYCBpZiB0aGUgdmFsdWUgaXMgZW1wdHkgKi9cbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgIH0pKTtcblxuICAgICAgfSksXG4gICAgICAvKiBUaGUgb2JzZXJ2YWJsZSB3aWxsIGNvbXBsZXRlIGFmdGVyIHRoZSBmaXJzdCB2YWx1ZSAqL1xuICAgICAgZmlyc3QoKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhbiBpdGVtIGluIG91ciBgaW5kZXhlZERCYCBzdG9yZVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEBwYXJhbSBkYXRhIFRoZSBpdGVtJ3MgdmFsdWVcbiAgICogQHJldHVybnMgQW4gUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIHNldChrZXk6IHN0cmluZywgZGF0YTogdW5rbm93bik6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICAvKiBTdG9yaW5nIGB1bmRlZmluZWRgIGluIGBpbmRleGVkRGJgIGNhbiBjYXVzZSBpc3N1ZXMgaW4gc29tZSBicm93c2VycyBzbyByZW1vdmluZyBpdGVtIGluc3RlYWQgKi9cbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxldGUoa2V5KTtcbiAgICB9XG5cbiAgICAvKiBPcGVuIGEgdHJhbnNhY3Rpb24gaW4gd3JpdGUgbW9kZSAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnKS5waXBlKFxuICAgICAgbWVyZ2VNYXAoKHRyYW5zYWN0aW9uRGF0YSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RvcmUsIGV2ZW50cyB9ID0gdHJhbnNhY3Rpb25EYXRhO1xuXG4gICAgICAgIC8qIFByaW9yIHRvIHY4LCBkYXRhIHdhcyB3cmFwcGVkIGluIGEgYHsgdmFsdWU6IC4uLiB9YCBvYmplY3QgKi9cbiAgICAgICAgY29uc3QgZGF0YVRvU3RvcmUgPSB0aGlzLm5vV3JhcCA/IGRhdGEgOiB7IFt0aGlzLndyYXBJbmRleF06IGRhdGEgfTtcblxuICAgICAgICAvKiBBZGQgaWYgdGhlIGl0ZW0gaXMgbm90IGV4aXN0aW5nIHlldCwgb3IgdXBkYXRlIG90aGVyd2lzZSAqL1xuICAgICAgICBzdG9yZS5wdXQoZGF0YVRvU3RvcmUsIGtleSk7XG5cbiAgICAgICAgLyogTGlzdGVuIHRvIGV2ZW50cyBhbmQgcmV0dXJuIGB1bmRlZmluZWRgIGFzIG5vIHZhbHVlIGlzIGV4cGVjdGVkICovXG4gICAgICAgIHJldHVybiBldmVudHMucGlwZShtYXBUbyh1bmRlZmluZWQpKTtcblxuICAgICAgfSksXG4gICAgICAvKiBUaGUgb2JzZXJ2YWJsZSB3aWxsIGNvbXBsZXRlIGFmdGVyIHRoZSBmaXJzdCB2YWx1ZSAqL1xuICAgICAgZmlyc3QoKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBpdGVtIGluIG91ciBgaW5kZXhlZERCYCBzdG9yZVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgYE9ic2VydmFibGVgIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICBkZWxldGUoa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPHVuZGVmaW5lZD4ge1xuXG4gICAgLyogT3BlbiBhIHRyYW5zYWN0aW9uIGluIHdyaXRlIG1vZGUgKi9cbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbigncmVhZHdyaXRlJykucGlwZShcbiAgICAgIG1lcmdlTWFwKCh0cmFuc2FjdGlvbkRhdGEpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN0b3JlLCBldmVudHMgfSA9IHRyYW5zYWN0aW9uRGF0YTtcblxuICAgICAgICAvKiBEZWxldGUgdGhlIGl0ZW0gaW4gc3RvcmUgKi9cbiAgICAgICAgc3RvcmUuZGVsZXRlKGtleSk7XG5cbiAgICAgICAgLyogTGlzdGVuIHRvIGV2ZW50cyBhbmQgcmV0dXJuIGB1bmRlZmluZWRgIGFzIG5vIGRhdGEgaXMgZXhwZWN0ZWQgaGVyZSAqL1xuICAgICAgICByZXR1cm4gZXZlbnRzLnBpcGUobWFwVG8odW5kZWZpbmVkKSk7XG5cbiAgICAgIH0pLFxuICAgICAgLyogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSBhZnRlciB0aGUgZmlyc3QgdmFsdWUgKi9cbiAgICAgIGZpcnN0KCksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIGl0ZW1zIGZyb20gb3VyIGBpbmRleGVkREJgIG9iamV0IHN0b3JlXG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgYE9ic2VydmFibGVgIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICBjbGVhcigpOiBPYnNlcnZhYmxlPHVuZGVmaW5lZD4ge1xuXG4gICAgLyogT3BlbiBhIHRyYW5zYWN0aW9uIGluIHdyaXRlIG1vZGUgKi9cbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbigncmVhZHdyaXRlJykucGlwZShcbiAgICAgIG1lcmdlTWFwKCh0cmFuc2FjdGlvbkRhdGEpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN0b3JlLCBldmVudHMgfSA9IHRyYW5zYWN0aW9uRGF0YTtcblxuICAgICAgICAvKiBEZWxldGUgYWxsIGl0ZW1zIGluIG9iamVjdCBzdG9yZSAqL1xuICAgICAgICBzdG9yZS5jbGVhcigpO1xuXG4gICAgICAgIC8qIExpc3RlbiB0byBldmVudHMgYW5kIHJldHVybiBgdW5kZWZpbmVkYCBhcyBubyBkYXRhIGlzIGV4cGVjdGVkIGhlcmUgKi9cbiAgICAgICAgcmV0dXJuIGV2ZW50cy5waXBlKG1hcFRvKHVuZGVmaW5lZCkpO1xuXG4gICAgICB9KSxcbiAgICAgIC8qIFRoZSBvYnNlcnZhYmxlIHdpbGwgY29tcGxldGUgKi9cbiAgICAgIGZpcnN0KCksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgdGhlIGtleXMgaW4gb3VyIGBpbmRleGVkREJgIHN0b3JlXG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgYE9ic2VydmFibGVgIGl0ZXJhdGluZyBvbiBlYWNoIGtleVxuICAgKi9cbiAga2V5cygpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuXG4gICAgLyogT3BlbiBhIHRyYW5zYWN0aW9uIGluIHJlYWQtb25seSBtb2RlICovXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oJ3JlYWRvbmx5JykucGlwZShcbiAgICAgIC8qIGBmaXJzdCgpYCBpcyB1c2VkIGFzIHRoZSBmaW5hbCBvcGVyYXRvciBpbiBvdGhlciBtZXRob2RzIHRvIGNvbXBsZXRlIHRoZSBgT2JzZXJ2YWJsZWBcbiAgICAgICAqIChhcyBpdCBhbGwgc3RhcnRzIGZyb20gYSBgUmVwbGF5U3ViamVjdGAgd2hpY2ggbmV2ZXIgZW5kcyksXG4gICAgICAgKiBidXQgYXMgdGhpcyBtZXRob2QgaXMgaXRlcmF0aW5nIG92ZXIgbXVsdGlwbGUgdmFsdWVzLCBgZmlyc3QoKWAgKiptdXN0KiogYmUgdXNlZCBoZXJlICovXG4gICAgICBmaXJzdCgpLFxuICAgICAgbWVyZ2VNYXAoKHRyYW5zYWN0aW9uRGF0YSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RvcmUgfSA9IHRyYW5zYWN0aW9uRGF0YTtcblxuICAgICAgICAvKiBPcGVuIGEgY3Vyc29yIG9uIHRoZSBzdG9yZVxuICAgICAgICAgKiBgLm9wZW5LZXlDdXJzb3IoKWAgaXMgYmV0dGVyIGZvciBwZXJmb3JtYW5jZSwgYnV0IG9ubHkgYXZhaWxhYmxlIGluIGluZGV4ZWREQiB2MiAobWlzc2luZyBpbiBJRSlcbiAgICAgICAgICogQXZvaWQgaXNzdWVzIGxpa2UgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9pc3N1ZXMvNjkgKi9cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9ICgnb3BlbktleUN1cnNvcicgaW4gc3RvcmUpID8gc3RvcmUub3BlbktleUN1cnNvcigpIDogKHN0b3JlIGFzIElEQk9iamVjdFN0b3JlKS5vcGVuQ3Vyc29yKCk7XG5cbiAgICAgICAgLyogTGlzdGVuIHRvIHN1Y2Nlc3MgZXZlbnQgKi9cbiAgICAgICAgY29uc3Qgc3VjY2VzcyQgPSBmcm9tRXZlbnQocmVxdWVzdCwgJ3N1Y2Nlc3MnKS5waXBlKFxuICAgICAgICAgIC8qIFN0b3AgdGhlIGBPYnNlcnZhYmxlYCB3aGVuIHRoZSBjdXJzb3IgaXMgYG51bGxgICovXG4gICAgICAgICAgdGFrZVdoaWxlKCgpID0+IChyZXF1ZXN0LnJlc3VsdCAhPT0gbnVsbCkpLFxuICAgICAgICAgIC8qIFRoaXMgbGliIG9ubHkgYWxsb3dzIHN0cmluZyBrZXlzLCBidXQgdXNlciBjb3VsZCBoYXZlIGFkZGVkIG90aGVyIHR5cGVzIG9mIGtleXMgZnJvbSBvdXRzaWRlXG4gICAgICAgICAgICogSXQncyBPSyB0byBjYXN0IGFzIHRoZSBjdXJzb3IgYXMgYmVlbiB0ZXN0ZWQgaW4gdGhlIHByZXZpb3VzIG9wZXJhdG9yICovXG4gICAgICAgICAgbWFwKCgpID0+IChyZXF1ZXN0LnJlc3VsdCBhcyBJREJDdXJzb3IpLmtleS50b1N0cmluZygpKSxcbiAgICAgICAgICAvKiBJdGVyYXRlIG9uIHRoZSBjdXJzb3IgKi9cbiAgICAgICAgICB0YXAoKCkgPT4geyAocmVxdWVzdC5yZXN1bHQgYXMgSURCQ3Vyc29yKS5jb250aW51ZSgpOyB9KSxcbiAgICAgICAgKTtcblxuICAgICAgICAvKiBMaXN0ZW4gdG8gZXJyb3IgZXZlbnQgYW5kIGlmIHNvLCB0aHJvdyBhbiBlcnJvciAqL1xuICAgICAgICBjb25zdCBlcnJvciQgPSB0aGlzLmxpc3RlbkVycm9yKHJlcXVlc3QpO1xuXG4gICAgICAgIC8qIENob29zZSB0aGUgZmlyc3QgZXZlbnQgdG8gb2NjdXIgKi9cbiAgICAgICAgcmV0dXJuIHJhY2UoW3N1Y2Nlc3MkLCBlcnJvciRdKTtcblxuICAgICAgfSksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEga2V5IGV4aXN0cyBpbiBvdXIgYGluZGV4ZWREQmAgc3RvcmVcbiAgICogQHJldHVybnMgQW4gUnhKUyBgT2JzZXJ2YWJsZWAgdGVsbGluZyBpZiB0aGUga2V5IGV4aXN0cyBvciBub3RcbiAgICovXG4gIGhhcyhrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuXG4gICAgLyogT3BlbiBhIHRyYW5zYWN0aW9uIGluIHJlYWQtb25seSBtb2RlICovXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oJ3JlYWRvbmx5JykucGlwZShcbiAgICAgIG1lcmdlTWFwKCh0cmFuc2FjdGlvbkRhdGEpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN0b3JlLCBldmVudHMgfSA9IHRyYW5zYWN0aW9uRGF0YTtcblxuICAgICAgICAvKiBDaGVjayBpZiB0aGUga2V5IGV4aXN0cyBpbiB0aGUgc3RvcmVcbiAgICAgICAgICogYGdldEtleSgpYCBpcyBiZXR0ZXIgYnV0IG9ubHkgYXZhaWxhYmxlIGluIGBpbmRleGVkREJgIHYyIChDaHJvbWUgPj0gNTgsIG1pc3NpbmcgaW4gSUUvRWRnZSBMZWdhY3kpLlxuICAgICAgICAgKiBJbiBvbGRlciBicm93c2VycywgdGhlIHZhbHVlIGlzIGNoZWNrZWQgaW5zdGVhZCwgYnV0IGl0IGNvdWxkIGxlYWQgdG8gYW4gZXhjZXB0aW9uXG4gICAgICAgICAqIGlmIGB1bmRlZmluZWRgIHdhcyBzdG9yZWQgb3V0c2lkZSBvZiB0aGlzIGxpYiAoZS5nLiBkaXJlY3RseSB3aXRoIHRoZSBuYXRpdmUgYGluZGV4ZWREQmAgQVBJKS5cbiAgICAgICAgICogRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9pc3N1ZXMvNjlcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSAgKCdnZXRLZXknIGluIHN0b3JlKSA/IHN0b3JlLmdldEtleShrZXkpIDogKHN0b3JlIGFzIElEQk9iamVjdFN0b3JlKS5nZXQoa2V5KTtcblxuICAgICAgICAvKiBMaXN0ZW4gdG8gZXZlbnRzIGFuZCByZXR1cm4gYHRydWVgIG9yIGBmYWxzZWAgKi9cbiAgICAgICAgcmV0dXJuIGV2ZW50cy5waXBlKG1hcCgoKSA9PiAocmVxdWVzdC5yZXN1bHQgIT09IHVuZGVmaW5lZCkgPyB0cnVlIDogZmFsc2UpKTtcblxuICAgICAgfSksXG4gICAgICAvKiBUaGUgb2JzZXJ2YWJsZSB3aWxsIGNvbXBsZXRlICovXG4gICAgICBmaXJzdCgpLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byBgaW5kZXhlZERCYCBhbmQgY3JlYXRlcyB0aGUgb2JqZWN0IHN0b3JlIG9uIGZpcnN0IHRpbWVcbiAgICovXG4gIHByb3RlY3RlZCBjb25uZWN0KCk6IHZvaWQge1xuXG4gICAgbGV0IHJlcXVlc3Q6IElEQk9wZW5EQlJlcXVlc3Q7XG5cbiAgICAvKiBDb25uZWN0IHRvIGBpbmRleGVkREJgXG4gICAgICogV2lsbCBmYWlsIGluIFNhZmFyaSBjcm9zcy1vcmlnaW4gaWZyYW1lc1xuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvaXNzdWVzLzQyfSAqL1xuICAgIHRyeSB7XG5cbiAgICAgIC8qIERvIE5PVCBleHBsaWNpdCBgd2luZG93YCBoZXJlLCBhcyBgaW5kZXhlZERCYCBjb3VsZCBiZSB1c2VkIGZyb20gYSB3ZWIgd29ya2VyIHRvbyAqL1xuICAgICAgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKHRoaXMuZGJOYW1lLCB0aGlzLmRiVmVyc2lvbik7XG5cbiAgICB9wqBjYXRjaCB7XG5cbiAgICAgIHRoaXMuZGF0YWJhc2UuZXJyb3IobmV3IElEQkJyb2tlbkVycm9yKCkpO1xuXG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICAvKiBDcmVhdGUgc3RvcmUgb24gZmlyc3QgY29ubmVjdGlvbiAqL1xuICAgIHRoaXMuY3JlYXRlU3RvcmUocmVxdWVzdCk7XG5cbiAgICAvKiBMaXN0ZW4gdG8gc3VjY2VzcyBhbmQgZXJyb3IgZXZlbnRzICovXG4gICAgY29uc3Qgc3VjY2VzcyQgPSBmcm9tRXZlbnQocmVxdWVzdCwgJ3N1Y2Nlc3MnKTtcbiAgICBjb25zdCBlcnJvciQgPSB0aGlzLmxpc3RlbkVycm9yKHJlcXVlc3QpO1xuXG4gICAgLyogQ2hvb3NlIHRoZSBmaXJzdCB0byBvY2N1ciAqL1xuICAgIHJhY2UoW3N1Y2Nlc3MkLCBlcnJvciRdKVxuICAgICAgLyogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSAqL1xuICAgICAgLnBpcGUoZmlyc3QoKSlcbiAgICAgIC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgLyogUmVnaXN0ZXIgdGhlIGRhdGFiYXNlIGNvbm5lY3Rpb24gaW4gdGhlIGBSZXBsYXlTdWJqZWN0YCBmb3IgZnVydGhlciBhY2Nlc3MgKi9cbiAgICAgICAgICB0aGlzLmRhdGFiYXNlLm5leHQocmVxdWVzdC5yZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogKCkgPT4ge1xuICAgICAgICAgIC8qIEZpcmVmb3ggcHJpdmF0ZSBtb2RlIGlzc3VlOiBmYWxsYmFjayBzdG9yYWdlIGlmIEluZGV4ZWREYiBjb25uZWN0aW9uIGlzIGZhaWxpbmdcbiAgICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc4MTk4Mn1cbiAgICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvaXNzdWVzLzI2fSAqL1xuICAgICAgICAgIHRoaXMuZGF0YWJhc2UuZXJyb3IobmV3IElEQkJyb2tlbkVycm9yKCkpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgc3RvcmUgb24gZmlyc3QgdXNlIG9mIGBpbmRleGVkREJgXG4gICAqIEBwYXJhbSByZXF1ZXN0IGBpbmRleGVkREJgIGRhdGFiYXNlIG9wZW5pbmcgcmVxdWVzdFxuICAgKi9cbiAgcHJvdGVjdGVkIGNyZWF0ZVN0b3JlKHJlcXVlc3Q6IElEQk9wZW5EQlJlcXVlc3QpOiB2b2lkIHtcblxuICAgIC8qIExpc3RlbiB0byB0aGUgZXZlbnQgZmlyZWQgb24gZmlyc3QgY29ubmVjdGlvbiAqL1xuICAgIGZyb21FdmVudChyZXF1ZXN0LCAndXBncmFkZW5lZWRlZCcpXG4gICAgICAvKiBUaGUgb2JzZXJ2YWJsZSB3aWxsIGNvbXBsZXRlICovXG4gICAgICAucGlwZShmaXJzdCgpKVxuICAgICAgLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6ICgpID0+IHtcblxuICAgICAgICAgIC8qIENoZWNrIGlmIHRoZSBzdG9yZSBhbHJlYWR5IGV4aXN0cywgdG8gYXZvaWQgZXJyb3IgKi9cbiAgICAgICAgICBpZiAoIXJlcXVlc3QucmVzdWx0Lm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnModGhpcy5zdG9yZU5hbWUpKSB7XG5cbiAgICAgICAgICAgIC8qIENyZWF0ZSB0aGUgb2JqZWN0IHN0b3JlICovXG4gICAgICAgICAgICByZXF1ZXN0LnJlc3VsdC5jcmVhdGVPYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuIGFuIGBpbmRleGVkREJgIHRyYW5zYWN0aW9uIGFuZCBnZXQgb3VyIHN0b3JlXG4gICAqIEBwYXJhbSBtb2RlIGByZWFkb25seWAgb3IgYHJlYWR3cml0ZWBcbiAgICogQHJldHVybnMgQW4gYGluZGV4ZWREQmAgdHJhbnNhY3Rpb24gc3RvcmUgYW5kIGV2ZW50cywgd3JhcHBlZCBpbiBhbiBSeEpTIGBPYnNlcnZhYmxlYFxuICAgKi9cbiAgcHJvdGVjdGVkIHRyYW5zYWN0aW9uKG1vZGU6IElEQlRyYW5zYWN0aW9uTW9kZSk6IE9ic2VydmFibGU8e1xuICAgIHN0b3JlOiBJREJPYmplY3RTdG9yZTtcbiAgICBldmVudHM6IE9ic2VydmFibGU8RXZlbnQ+O1xuICB9PiB7XG5cbiAgICAvKiBGcm9tIHRoZSBgaW5kZXhlZERCYCBjb25uZWN0aW9uLCBvcGVuIGEgdHJhbnNhY3Rpb24gYW5kIGdldCB0aGUgc3RvcmUgKi9cbiAgICByZXR1cm4gdGhpcy5kYXRhYmFzZVxuICAgICAgLnBpcGUobWVyZ2VNYXAoKGRhdGFiYXNlKSA9PiB7XG5cbiAgICAgICAgbGV0IHRyYW5zYWN0aW9uOiBJREJUcmFuc2FjdGlvbjtcblxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSBkYXRhYmFzZS50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCBtb2RlKTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXG4gICAgICAgICAgICAvKiBUaGUgc3RvcmUgY291bGQgaGF2ZSBiZWVuIGRlbGV0ZWQgZnJvbSBvdXRzaWRlICovXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvciBhcyBET01FeGNlcHRpb24pO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvKiBHZXQgdGhlIHN0b3JlIGZyb20gdGhlIHRyYW5zYWN0aW9uICovXG4gICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuXG4gICAgICAgIC8qIExpc3RlbiB0cmFuc2FjdGlvbiBgY29tcGxldGVgIGFuZCBgZXJyb3JgIGV2ZW50cyAqL1xuICAgICAgICBjb25zdCBldmVudHMgPSB0aGlzLmxpc3RlblRyYW5zYWN0aW9uRXZlbnRzKHRyYW5zYWN0aW9uKTtcblxuICAgICAgICByZXR1cm4gb2YoeyBzdG9yZSwgZXZlbnRzIH0pO1xuXG4gICAgICB9KSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gZXJyb3JzIG9uIGEgdHJhbnNhY3Rpb24gb3IgcmVxdWVzdCwgYW5kIHRocm93IGlmIHRyaWdlcnJlZFxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25PclJlcXVlc3QgYGluZGV4ZWREYmAgdHJhbnNhY3Rpb24gb3IgcmVxdWVzdCB0byBsaXN0ZW5cbiAgICogQHJldHVybnMgQW4gYE9ic2VydmFibGVgIGxpc3RlbmluZyB0byBlcnJvcnNcbiAgICovXG4gIHByb3RlY3RlZCBsaXN0ZW5FcnJvcih0cmFuc2FjdGlvbk9yUmVxdWVzdDogSURCVHJhbnNhY3Rpb24gfCBJREJSZXF1ZXN0KTogT2JzZXJ2YWJsZTxuZXZlcj4ge1xuXG4gICAgcmV0dXJuIGZyb21FdmVudCh0cmFuc2FjdGlvbk9yUmVxdWVzdCwgJ2Vycm9yJykucGlwZShcbiAgICAgIC8qIFRocm93IG9uIGVycm9yIHRvIGJlIGFibGUgdG8gY2F0Y2ggZXJyb3JzIGluIFJ4SlMgd2F5LlxuICAgICAgICogSGVyZSBgZXZlbnQudGFyZ2V0YCBtdXN0IGJlIHVzZWQsIGFzIGB0cmFuc2FjdGlvbk9yUmVxdWVzdC5lcnJvcmAgd2lsbCBiZSBgbnVsbGBcbiAgICAgICAqIGlmIHdlIGFyZSBvbiB0aGUgcmVxdWVzdCBhbmQgdGhlIGVycm9yIGlzIG9ubHkgdHJpZ2dlcmVkIGxhdGVyIGJ5IHRoZSB0cmFuc2FjdGlvbiAqL1xuICAgICAgbWVyZ2VNYXAoKGV2ZW50KSA9PiB0aHJvd0Vycm9yKChldmVudC50YXJnZXQgYXMgSURCVHJhbnNhY3Rpb24gfCBJREJSZXF1ZXN0KS5lcnJvcikpLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdHJhbnNhY3Rpb24gYGNvbXBsZXRlYCBhbmQgYGVycm9yYCBldmVudHNcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIHRvIGxpc3RlblxuICAgKiBAcmV0dXJucyBBbiBgT2JzZXJ2YWJsZWAgbGlzdGVuaW5nIHRvIHRyYW5zYWN0aW9uIGBjb21wbGV0ZWAgYW5kIGBlcnJvcmAgZXZlbnRzXG4gICAqL1xuICBwcm90ZWN0ZWQgbGlzdGVuVHJhbnNhY3Rpb25FdmVudHModHJhbnNhY3Rpb246IElEQlRyYW5zYWN0aW9uKTogT2JzZXJ2YWJsZTxFdmVudD4ge1xuXG4gICAgLyogTGlzdGVuIHRvIHRoZSBgY29tcGxldGVgIGV2ZW50ICovXG4gICAgY29uc3QgY29tcGxldGUkID0gZnJvbUV2ZW50KHRyYW5zYWN0aW9uLCAnY29tcGxldGUnKTtcblxuICAgIC8qIExpc3RlbiB0byB0aGUgYGVycm9yYCBldmVudCAqL1xuICAgIGNvbnN0IGVycm9yJCA9IHRoaXMubGlzdGVuRXJyb3IodHJhbnNhY3Rpb24pO1xuXG4gICAgLyogQ2hvb3NlIHRoZSBmaXJzdCBldmVudCB0byBvY2N1ciAqL1xuICAgIHJldHVybiByYWNlKFtjb21wbGV0ZSQsIGVycm9yJF0pO1xuXG4gIH1cblxufVxuIl19