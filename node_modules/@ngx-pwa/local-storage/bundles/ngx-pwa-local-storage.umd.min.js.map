{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","../../../projects/ngx-pwa/local-storage/src/lib/validation/json-validator.ts","../../../../projects/ngx-pwa/local-storage/src/lib/tokens.ts","../../../projects/ngx-pwa/local-storage/src/lib/databases/exceptions.ts","../../../projects/ngx-pwa/local-storage/src/lib/databases/indexeddb-database.ts","../../../projects/ngx-pwa/local-storage/src/lib/databases/localstorage-database.ts","../../../projects/ngx-pwa/local-storage/src/lib/databases/memory-database.ts","../../../projects/ngx-pwa/local-storage/src/lib/databases/local-database.ts","../../../projects/ngx-pwa/local-storage/src/lib/storages/exceptions.ts","../../../projects/ngx-pwa/local-storage/src/lib/storages/storage-map.service.ts","../../../projects/ngx-pwa/local-storage/src/lib/storages/local-storage.service.ts","../../../../projects/ngx-pwa/local-storage/src/lib/storage.module.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","__","this","constructor","create","__values","o","s","Symbol","iterator","m","i","length","next","value","done","TypeError","__read","n","r","e","ar","push","error","__spread","arguments","concat","JSONValidator","validate","data","schema","type","validateString","validateNumber","validateBoolean","validateArray","validateObject","validateConst","validateEnum","undefined","maxLength","minLength","pattern","regularExpression","RegExp","_a","test","Number","isInteger","multipleOf","maximum","exclusiveMaximum","minimum","exclusiveMinimum","isArray","maxItems","minItems","uniqueItems","dataSet","Set","size","items","validateTuple","data_1","data_1_1","schemas","keys","properties","required","_c","_d","requiredProp","property","const","enum","includes","Injectable","args","providedIn","LS_PREFIX","InjectionToken","factory","DEFAULT_IDB_DB_NAME","IDB_DB_NAME","IDB_DB_VERSION","DEFAULT_IDB_STORE_NAME","IDB_STORE_NAME","IDB_NO_WRAP","IDB_BROKEN_ERROR","IDBBrokenError","_super","_this","apply","message","Error","SERIALIZATION_ERROR","SerializationError","IndexedDBDatabase","dbName","storeName","dbVersion","noWrap","database","ReplaySubject","wrapIndex","connect","defineProperty","store","version","transaction","pipe","mergeMap","transactionData","events","request","count","map","result","first","get","key","set","delete","dataToStore","_b","put","mapTo","clear","openKeyCursor","openCursor","success$","fromEvent","takeWhile","toString","tap","continue","error$","listenError","race","has","getKey","indexedDB","open","createStore","subscribe","objectStoreNames","contains","createObjectStore","mode","throwError","objectStore","listenTransactionEvents","of","transactionOrRequest","event","target","complete$","Inject","LocalStorageDatabase","prefix","localStorage","parsedData","unparsedData","getItem","prefixKey","JSON","parse","serializedData","dataPrototype","getPrototypeOf","stringify","setItem","removeItem","Observable","subscriber","index","getUnprefixedKey","complete","observeOn","asyncScheduler","prefixedKey","substr","MemoryDatabase","memoryStorage","Map","from","localDatabaseFactory","platformId","LSPrefix","IDBDBName","IDBStoreName","IDBDBVersion","IDBNoWrap","isPlatformBrowser","useFactory","deps","PLATFORM_ID","VALIDATION_ERROR","ValidationError","StorageMap","jsonValidator","notifiers","catchIDBBroken","backingStore","notify","watch","notifier","asObservable","operationCallback","catchError","LocalDatabase","LocalStorage","storageMap","StorageModule","forRoot","config","ngModule","providers","provide","useValue","NgModule"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Injectable } from '@angular/core';\n\nimport {\n  JSONSchema, JSONSchemaString, JSONSchemaInteger, JSONSchemaNumber, JSONSchemaBoolean,\n  JSONSchemaArray, JSONSchemaObject\n} from './json-schema';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class JSONValidator {\n\n  /**\n   * Validate a JSON data against a Jsubset of the JSON Schema standard.\n   * Types are enforced to validate everything: each schema must\n   * @param data JSON data to validate\n   * @param schema Subset of JSON Schema. Must have a `type`.\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  validate(data: unknown, schema: JSONSchema): boolean {\n\n    switch (schema.type) {\n\n      case 'string':\n        return this.validateString(data, schema);\n      case 'number':\n      case 'integer':\n        return this.validateNumber(data, schema);\n      case 'boolean':\n        return this.validateBoolean(data, schema);\n      case 'array':\n        return this.validateArray(data, schema);\n      case 'object':\n        return this.validateObject(data, schema);\n\n    }\n\n  }\n\n  /**\n   * Validate a string\n   * @param data Data to validate\n   * @param schema Schema describing the string\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n  protected validateString(data: unknown, schema: JSONSchemaString): boolean {\n\n    if (typeof data !== 'string') {\n      return false;\n    }\n\n    if (!this.validateConst(data, schema)) {\n      return false;\n    }\n\n    if (!this.validateEnum(data, schema)) {\n      return false;\n    }\n\n    if ((schema.maxLength !== undefined) && (data.length > schema.maxLength)) {\n      return false;\n    }\n\n    if ((schema.minLength !== undefined) && (data.length < schema.minLength)) {\n      return false;\n    }\n\n    if (schema.pattern) {\n\n      let regularExpression: RegExp | null = null;\n\n      try {\n        regularExpression = new RegExp(schema.pattern);\n      } catch {}\n\n      if (regularExpression && !regularExpression.test(data)) {\n        return false;\n      }\n\n    }\n\n    return true;\n\n  }\n\n  /**\n   * Validate a number or an integer\n   * @param data Data to validate\n   * @param schema Schema describing the number or integer\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n  protected validateNumber(data: unknown, schema: JSONSchemaNumber | JSONSchemaInteger): boolean {\n\n    if (typeof data !== 'number') {\n      return false;\n    }\n\n    if ((schema.type === 'integer') && !Number.isInteger(data)) {\n      return false;\n    }\n\n    if (!this.validateConst(data, schema)) {\n      return false;\n    }\n\n    if (!this.validateEnum(data, schema)) {\n      return false;\n    }\n\n    /* Test is done this way to not divide by 0 */\n    if (schema.multipleOf && !Number.isInteger(data / schema.multipleOf)) {\n      return false;\n    }\n\n    if ((schema.maximum !== undefined) && (data > schema.maximum)) {\n        return false;\n    }\n\n    if ((schema.exclusiveMaximum !== undefined) && (data >= schema.exclusiveMaximum)) {\n      return false;\n\n    }\n\n    if ((schema.minimum !== undefined) && (data < schema.minimum)) {\n      return false;\n\n    }\n\n    if ((schema.exclusiveMinimum !== undefined) && (data <= schema.exclusiveMinimum)) {\n        return false;\n    }\n\n    return true;\n\n  }\n\n  /**\n   * Validate a boolean\n   * @param data Data to validate\n   * @param schema Schema describing the boolean\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n  protected validateBoolean(data: unknown, schema: JSONSchemaBoolean): boolean {\n\n    if (typeof data !== 'boolean') {\n      return false;\n    }\n\n    if (!this.validateConst(data, schema)) {\n      return false;\n    }\n\n    return true;\n\n  }\n\n  /**\n   * Validate an array\n   * @param data Data to validate\n   * @param schema Schema describing the array\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n  protected validateArray(data: unknown, schema: JSONSchemaArray): boolean {\n\n    if (!Array.isArray(data)) {\n      return false;\n    }\n\n    if ((schema.maxItems !== undefined) && (data.length > schema.maxItems)) {\n      return false;\n    }\n\n    if ((schema.minItems !== undefined) && (data.length < schema.minItems)) {\n      return false;\n    }\n\n    if (schema.uniqueItems) {\n\n      /* Create a set to eliminate values with multiple occurences */\n      const dataSet = new Set(data);\n\n      if (data.length !== dataSet.size) {\n        return false;\n      }\n\n    }\n\n    /* Specific test for tuples */\n    if (Array.isArray(schema.items)) {\n\n      return this.validateTuple(data, schema.items);\n\n    }\n\n    /* Validate all the values in array */\n    for (const value of data) {\n\n      // TODO: remove when TypeScript 4.1 is available\n      // (currently the narrowed type from `Array.isArray()` is lost on readonly arrays)\n      if (!this.validate(value, schema.items as JSONSchema)) {\n        return false;\n      }\n\n    }\n\n    return true;\n\n  }\n\n  /**\n   * Validate a tuple (array with fixed length and multiple types)\n   * @param data Data to validate\n   * @param schemas Schemas describing the tuple\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n  protected validateTuple(data: unknown[], schemas: JSONSchema[]): boolean {\n\n    /* Tuples have a fixed length */\n    if (data.length !== schemas.length) {\n\n      return false;\n\n    }\n\n    for (let i = 0; i < schemas.length; i += 1) {\n\n      if (!this.validate(data[i], schemas[i])) {\n        return false;\n      }\n\n    }\n\n    return true;\n\n  }\n\n  /**\n   * Validate an object\n   * @param data Data to validate\n   * @param schema JSON schema describing the object\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n  protected validateObject(data: unknown, schema: JSONSchemaObject): boolean {\n\n    /* Check the type and if not `null` as `null` also have the type `object` in old browsers */\n    if ((typeof data !== 'object') || (data === null)) {\n      return false;\n    }\n\n    /* Check if the object doesn't have more properties than expected\n     * Equivalent of `additionalProperties: false`\n     */\n    if (Object.keys(schema.properties).length < Object.keys(data).length) {\n      return false;\n    }\n\n    /* Validate required properties */\n    if (schema.required) {\n\n      for (const requiredProp of schema.required) {\n\n        if (!data.hasOwnProperty(requiredProp)) {\n          return false;\n        }\n\n      }\n\n    }\n\n    /* Recursively validate all properties */\n    for (const property in schema.properties) {\n\n      /* Filter to keep only real properties (no internal JS stuff) and check if the data has the property too */\n      if (schema.properties.hasOwnProperty(property) && data.hasOwnProperty(property)) {\n\n        if (!this.validate((data as { [k: string]: unknown; })[property], schema.properties[property])) {\n          return false;\n        }\n\n      }\n\n    }\n\n    return true;\n\n  }\n\n  /**\n   * Validate a constant\n   * @param data Data ta validate\n   * @param schema JSON schema describing the constant\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n  protected validateConst(data: unknown, schema: JSONSchemaBoolean | JSONSchemaInteger | JSONSchemaNumber | JSONSchemaString): boolean {\n\n    if (!schema.const) {\n      return true;\n    }\n\n    return (data === schema.const);\n\n  }\n\n  /**\n   * Validate an enum\n   * @param data Data ta validate\n   * @param schema JSON schema describing the enum\n   * @returns If data is valid: `true`, if it is invalid: `false`\n   */\n  protected validateEnum(data: unknown, schema: JSONSchemaInteger | JSONSchemaNumber | JSONSchemaString): boolean {\n\n    if (!schema.enum) {\n      return true;\n    }\n\n    /* Cast as the data can be of multiple types, and so TypeScript is lost */\n    return ((schema.enum as unknown[]).includes(data));\n\n  }\n\n}\n","import { InjectionToken } from '@angular/core';\n\n/**\n * Token to provide a prefix to `localStorage` keys.\n */\nexport const LS_PREFIX = new InjectionToken<string>('localStoragePrefix', {\n  providedIn: 'root',\n  factory: () => ''\n});\n\n/**\n * Default name used for `indexedDB` database.\n */\nexport const DEFAULT_IDB_DB_NAME = 'ngStorage';\n\n/**\n * Token to provide `indexedDB` database name.\n */\nexport const IDB_DB_NAME = new InjectionToken<string>('localStorageIDBDBName', {\n  providedIn: 'root',\n  factory: () => DEFAULT_IDB_DB_NAME\n});\n\n/**\n * Default version used for `indexedDB` database.\n */\nexport const DEFAULT_IDB_DB_VERSION = 1;\n\n/**\n * Token to provide `indexedDB` database version.\n * Must be an unsigned **integer**.\n */\nexport const IDB_DB_VERSION = new InjectionToken<number>('localStorageIDBDBVersion', {\n  providedIn: 'root',\n  factory: () => DEFAULT_IDB_DB_VERSION\n});\n\n/**\n * Default name used for `indexedDB` object store.\n */\nexport const DEFAULT_IDB_STORE_NAME = 'localStorage';\n\n/**\n * Token to provide `indexedDB` store name.\n * For backward compatibility, the default can't be set now, `IndexedDBDatabase` will do it at runtime.\n */\nexport const IDB_STORE_NAME = new InjectionToken<string>('localStorageIDBStoreName', {\n  providedIn: 'root',\n  factory: () => DEFAULT_IDB_STORE_NAME\n});\n\n/**\n * Default value for interoperability with native `indexedDB` and other storage libs,\n * by changing how values are stored in `indexedDB` database.\n */\nexport const DEFAULT_IDB_NO_WRAP = true;\n\n/**\n * Token to allow interoperability with native `indexedDB` and other storage libs,\n * by changing how values are stored in `indexedDB` database.\n * Defaults to `true`. Change to `false` for backward compatiblity in existing applications.\n * **DO NOT CHANGE THIS BEHAVIOR ONCE IN PRODUCTION**, as it would break with existing data.\n */\nexport const IDB_NO_WRAP = new InjectionToken<boolean>('localStorageIDBWrap', {\n  providedIn: 'root',\n  factory: () => DEFAULT_IDB_NO_WRAP\n});\n\nexport interface StorageConfig {\n\n  /**\n   * Allows to add a prefix before `localStorage` keys.\n   * *Use only* for interoperability with other APIs or to avoid collision for multiple apps on the same subdomain.\n   * **WARNING: do not change this option in an app already deployed in production, as previously stored data would be lost.**\n   */\n  LSPrefix?: string;\n\n  /**\n   * Allows to change the name used for `indexedDB` database.\n   * *Use only* for interoperability with other APIs or to avoid collision for multiple apps on the same subdomain.\n   * **WARNING: do not change this option in an app already deployed in production, as previously stored data would be lost.**\n   */\n  IDBDBName?: string;\n\n  /**\n   * Allows to change the name used for `indexedDB` object store.\n   * *Use only* for interoperability with other APIs.\n   * **WARNING: do not change this option in an app already deployed in production, as previously stored data would be lost.**\n   */\n  IDBStoreName?: string;\n\n  /**\n   * Allows to change the database version used for `indexedDB` database.\n   * Must be an unsigned **integer**.\n   * **Use with caution as the creation of the store depends on the version.**\n   * *Use only* for interoperability with other APIs or to avoid collision for multiple apps on the same subdomain.\n   * **WARNING: do not change this option in an app already deployed in production, as previously stored data would be lost.**\n   */\n  IDBDBVersion?: number;\n\n  /**\n   * Allows interoperability with native `indexedDB` and other storage libs,\n   * by changing how values are stored in `indexedDB` database.\n   * Defaults to `true`. Change to `false` for backward compatiblity in existing applications.\n   * **DO NOT CHANGE THIS BEHAVIOR ONCE IN PRODUCTION**, as it would break with existing data.\n   */\n  IDBNoWrap?: boolean;\n\n}\n","/**\n * Exception message when `indexedDB` is not working\n */\nexport const IDB_BROKEN_ERROR = 'indexedDB is not working';\n\n/**\n * Exception raised when `indexedDB` is not working\n */\nexport class IDBBrokenError extends Error {\n  message = IDB_BROKEN_ERROR;\n}\n\n/**\n * Exception message when a value can't be serialized for `localStorage`\n */\nexport const SERIALIZATION_ERROR = `The storage is currently localStorage,\nwhere data must be serialized, and the provided data can't be serialized.`;\n\n/**\n * Exception raised when a value can't be serialized for `localStorage`\n */\nexport class SerializationError extends Error {\n  message = SERIALIZATION_ERROR;\n}\n","import { Injectable, Inject } from '@angular/core';\nimport { Observable, ReplaySubject, fromEvent, of, throwError, race } from 'rxjs';\nimport { map, mergeMap, first, takeWhile, tap, mapTo } from 'rxjs/operators';\n\nimport {\n  IDB_DB_NAME, IDB_STORE_NAME, DEFAULT_IDB_STORE_NAME, IDB_DB_VERSION,\n  DEFAULT_IDB_DB_NAME, DEFAULT_IDB_DB_VERSION, IDB_NO_WRAP, DEFAULT_IDB_NO_WRAP\n} from '../tokens';\nimport { IDBBrokenError } from './exceptions';\nimport { LocalDatabase } from './local-database';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class IndexedDBDatabase implements LocalDatabase {\n\n  /**\n   * `indexedDB` database name\n   */\n  protected readonly dbName: string;\n\n  /**\n   * `indexedDB` object store name\n   */\n  protected readonly storeName: string;\n\n  /**\n   * `indexedDB` database version. Must be an unsigned **integer**\n   */\n  protected readonly dbVersion: number;\n\n  /**\n   * `indexedDB` database connection, wrapped in a RxJS `ReplaySubject` to be able to access the connection\n   * even after the connection success event happened\n   */\n  protected readonly database = new ReplaySubject<IDBDatabase>(1);\n\n  /**\n   * Flag to not wrap `indexedDB` values for interoperability or to wrap for backward compatibility.\n   */\n  protected readonly noWrap: boolean;\n\n  /**\n   * Index used when wrapping value. *For backward compatibility only.*\n   */\n  protected readonly wrapIndex = 'value';\n\n  /**\n   * Constructor params are provided by Angular (but can also be passed manually in tests)\n   * @param dbName `indexedDB` database name\n   * @param storeName `indexedDB` store name\n   * @param dbVersion `indexedDB` database version\n   * @param noWrap Flag to not wrap `indexedDB` values for interoperability or to wrap for backward compatibility\n   */\n  constructor(\n    @Inject(IDB_DB_NAME) dbName = DEFAULT_IDB_DB_NAME,\n    @Inject(IDB_STORE_NAME) storeName = DEFAULT_IDB_STORE_NAME,\n    @Inject(IDB_DB_VERSION) dbVersion = DEFAULT_IDB_DB_VERSION,\n    @Inject(IDB_NO_WRAP) noWrap = DEFAULT_IDB_NO_WRAP,\n  ) {\n\n    this.dbName = dbName;\n    this.storeName = storeName;\n    this.dbVersion = dbVersion;\n    this.noWrap = noWrap;\n\n    /* Connect to `indexedDB`, with prefix if provided by the user */\n    this.connect();\n\n  }\n\n  /**\n   * Information about `indexedDB` connection. *Only useful for interoperability.*\n   * @returns `indexedDB` database name, store name and database version\n   */\n  get backingStore(): { database: string, store: string, version: number } {\n\n    return {\n      database: this.dbName,\n      store: this.storeName,\n      version: this.dbVersion,\n    };\n\n  }\n\n  /**\n   * Number of items in our `indexedDB` database and object store\n   */\n  get size(): Observable<number> {\n\n    /* Open a transaction in read-only mode */\n    return this.transaction('readonly').pipe(\n      mergeMap((transactionData) => {\n\n        const { store, events } = transactionData;\n\n        /* Request to know the number of items */\n        const request = store.count();\n\n        /* Return the result */\n        return events.pipe(map(() => request.result));\n\n      }),\n      /* The observable will complete after the first value */\n      first(),\n    );\n\n  }\n\n  /**\n   * Gets an item value in our `indexedDB` store\n   * @param key The item's key\n   * @returns The item's value if the key exists, `undefined` otherwise, wrapped in an RxJS `Observable`\n   */\n  get(key: string): Observable<unknown | undefined> {\n\n    /* Open a transaction in read-only mode */\n    return this.transaction('readonly').pipe(\n      mergeMap((transactionData) => {\n\n        const { store, events } = transactionData;\n\n        /* Request the value with the key provided by the user */\n        const request = store.get(key);\n\n        /* Listen events and return the result */\n        return events.pipe(map(() => {\n\n          if ((request.result !== undefined) && (request.result !== null)) {\n\n            /* Prior to v8, the value was wrapped in an `{ value: ...}` object */\n            if (!this.noWrap && (typeof request.result === 'object') && (this.wrapIndex in request.result) &&\n            (request.result[this.wrapIndex] !== undefined) && (request.result[this.wrapIndex] !== null)) {\n\n              return request.result[this.wrapIndex];\n\n            } else {\n\n              /* Cast to the wanted type */\n              return request.result;\n\n            }\n\n          }\n\n          /* Return `undefined` if the value is empty */\n          return undefined;\n\n        }));\n\n      }),\n      /* The observable will complete after the first value */\n      first(),\n    );\n\n  }\n\n  /**\n   * Sets an item in our `indexedDB` store\n   * @param key The item's key\n   * @param data The item's value\n   * @returns An RxJS `Observable` to wait the end of the operation\n   */\n  set(key: string, data: unknown): Observable<undefined> {\n\n    /* Storing `undefined` in `indexedDb` can cause issues in some browsers so removing item instead */\n    if (data === undefined) {\n      return this.delete(key);\n    }\n\n    /* Open a transaction in write mode */\n    return this.transaction('readwrite').pipe(\n      mergeMap((transactionData) => {\n\n        const { store, events } = transactionData;\n\n        /* Prior to v8, data was wrapped in a `{ value: ... }` object */\n        const dataToStore = this.noWrap ? data : { [this.wrapIndex]: data };\n\n        /* Add if the item is not existing yet, or update otherwise */\n        store.put(dataToStore, key);\n\n        /* Listen to events and return `undefined` as no value is expected */\n        return events.pipe(mapTo(undefined));\n\n      }),\n      /* The observable will complete after the first value */\n      first(),\n    );\n\n  }\n\n  /**\n   * Deletes an item in our `indexedDB` store\n   * @param key The item's key\n   * @returns An RxJS `Observable` to wait the end of the operation\n   */\n  delete(key: string): Observable<undefined> {\n\n    /* Open a transaction in write mode */\n    return this.transaction('readwrite').pipe(\n      mergeMap((transactionData) => {\n\n        const { store, events } = transactionData;\n\n        /* Delete the item in store */\n        store.delete(key);\n\n        /* Listen to events and return `undefined` as no data is expected here */\n        return events.pipe(mapTo(undefined));\n\n      }),\n      /* The observable will complete after the first value */\n      first(),\n    );\n\n  }\n\n  /**\n   * Deletes all items from our `indexedDB` objet store\n   * @returns An RxJS `Observable` to wait the end of the operation\n   */\n  clear(): Observable<undefined> {\n\n    /* Open a transaction in write mode */\n    return this.transaction('readwrite').pipe(\n      mergeMap((transactionData) => {\n\n        const { store, events } = transactionData;\n\n        /* Delete all items in object store */\n        store.clear();\n\n        /* Listen to events and return `undefined` as no data is expected here */\n        return events.pipe(mapTo(undefined));\n\n      }),\n      /* The observable will complete */\n      first(),\n    );\n\n  }\n\n  /**\n   * Get all the keys in our `indexedDB` store\n   * @returns An RxJS `Observable` iterating on each key\n   */\n  keys(): Observable<string> {\n\n    /* Open a transaction in read-only mode */\n    return this.transaction('readonly').pipe(\n      /* `first()` is used as the final operator in other methods to complete the `Observable`\n       * (as it all starts from a `ReplaySubject` which never ends),\n       * but as this method is iterating over multiple values, `first()` **must** be used here */\n      first(),\n      mergeMap((transactionData) => {\n\n        const { store } = transactionData;\n\n        /* Open a cursor on the store\n         * `.openKeyCursor()` is better for performance, but only available in indexedDB v2 (missing in IE)\n         * Avoid issues like https://github.com/cyrilletuzi/angular-async-local-storage/issues/69 */\n        const request = ('openKeyCursor' in store) ? store.openKeyCursor() : (store as IDBObjectStore).openCursor();\n\n        /* Listen to success event */\n        const success$ = fromEvent(request, 'success').pipe(\n          /* Stop the `Observable` when the cursor is `null` */\n          takeWhile(() => (request.result !== null)),\n          /* This lib only allows string keys, but user could have added other types of keys from outside\n           * It's OK to cast as the cursor as been tested in the previous operator */\n          map(() => (request.result as IDBCursor).key.toString()),\n          /* Iterate on the cursor */\n          tap(() => { (request.result as IDBCursor).continue(); }),\n        );\n\n        /* Listen to error event and if so, throw an error */\n        const error$ = this.listenError(request);\n\n        /* Choose the first event to occur */\n        return race([success$, error$]);\n\n      }),\n    );\n\n  }\n\n  /**\n   * Check if a key exists in our `indexedDB` store\n   * @returns An RxJS `Observable` telling if the key exists or not\n   */\n  has(key: string): Observable<boolean> {\n\n    /* Open a transaction in read-only mode */\n    return this.transaction('readonly').pipe(\n      mergeMap((transactionData) => {\n\n        const { store, events } = transactionData;\n\n        /* Check if the key exists in the store\n         * `getKey()` is better but only available in `indexedDB` v2 (Chrome >= 58, missing in IE/Edge Legacy).\n         * In older browsers, the value is checked instead, but it could lead to an exception\n         * if `undefined` was stored outside of this lib (e.g. directly with the native `indexedDB` API).\n         * Fixes https://github.com/cyrilletuzi/angular-async-local-storage/issues/69\n         */\n        const request =  ('getKey' in store) ? store.getKey(key) : (store as IDBObjectStore).get(key);\n\n        /* Listen to events and return `true` or `false` */\n        return events.pipe(map(() => (request.result !== undefined) ? true : false));\n\n      }),\n      /* The observable will complete */\n      first(),\n    );\n\n  }\n\n  /**\n   * Connects to `indexedDB` and creates the object store on first time\n   */\n  protected connect(): void {\n\n    let request: IDBOpenDBRequest;\n\n    /* Connect to `indexedDB`\n     * Will fail in Safari cross-origin iframes\n     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42} */\n    try {\n\n      /* Do NOT explicit `window` here, as `indexedDB` could be used from a web worker too */\n      request = indexedDB.open(this.dbName, this.dbVersion);\n\n    } catch {\n\n      this.database.error(new IDBBrokenError());\n\n      return;\n\n    }\n\n    /* Create store on first connection */\n    this.createStore(request);\n\n    /* Listen to success and error events */\n    const success$ = fromEvent(request, 'success');\n    const error$ = this.listenError(request);\n\n    /* Choose the first to occur */\n    race([success$, error$])\n      /* The observable will complete */\n      .pipe(first())\n      .subscribe({\n        next: () => {\n          /* Register the database connection in the `ReplaySubject` for further access */\n          this.database.next(request.result);\n        },\n        error: () => {\n          /* Firefox private mode issue: fallback storage if IndexedDb connection is failing\n          * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}\n          * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/26} */\n          this.database.error(new IDBBrokenError());\n        },\n      });\n\n  }\n\n  /**\n   * Create store on first use of `indexedDB`\n   * @param request `indexedDB` database opening request\n   */\n  protected createStore(request: IDBOpenDBRequest): void {\n\n    /* Listen to the event fired on first connection */\n    fromEvent(request, 'upgradeneeded')\n      /* The observable will complete */\n      .pipe(first())\n      .subscribe({\n        next: () => {\n\n          /* Check if the store already exists, to avoid error */\n          if (!request.result.objectStoreNames.contains(this.storeName)) {\n\n            /* Create the object store */\n            request.result.createObjectStore(this.storeName);\n\n          }\n\n        }\n      });\n\n  }\n\n  /**\n   * Open an `indexedDB` transaction and get our store\n   * @param mode `readonly` or `readwrite`\n   * @returns An `indexedDB` transaction store and events, wrapped in an RxJS `Observable`\n   */\n  protected transaction(mode: IDBTransactionMode): Observable<{\n    store: IDBObjectStore;\n    events: Observable<Event>;\n  }> {\n\n    /* From the `indexedDB` connection, open a transaction and get the store */\n    return this.database\n      .pipe(mergeMap((database) => {\n\n        let transaction: IDBTransaction;\n\n        try {\n\n          transaction = database.transaction([this.storeName], mode);\n\n        } catch (error) {\n\n            /* The store could have been deleted from outside */\n            return throwError(error as DOMException);\n\n        }\n\n        /* Get the store from the transaction */\n        const store = transaction.objectStore(this.storeName);\n\n        /* Listen transaction `complete` and `error` events */\n        const events = this.listenTransactionEvents(transaction);\n\n        return of({ store, events });\n\n      }));\n\n  }\n\n  /**\n   * Listen errors on a transaction or request, and throw if trigerred\n   * @param transactionOrRequest `indexedDb` transaction or request to listen\n   * @returns An `Observable` listening to errors\n   */\n  protected listenError(transactionOrRequest: IDBTransaction | IDBRequest): Observable<never> {\n\n    return fromEvent(transactionOrRequest, 'error').pipe(\n      /* Throw on error to be able to catch errors in RxJS way.\n       * Here `event.target` must be used, as `transactionOrRequest.error` will be `null`\n       * if we are on the request and the error is only triggered later by the transaction */\n      mergeMap((event) => throwError((event.target as IDBTransaction | IDBRequest).error)),\n    );\n\n  }\n\n  /**\n   * Listen transaction `complete` and `error` events\n   * @param transaction Transaction to listen\n   * @returns An `Observable` listening to transaction `complete` and `error` events\n   */\n  protected listenTransactionEvents(transaction: IDBTransaction): Observable<Event> {\n\n    /* Listen to the `complete` event */\n    const complete$ = fromEvent(transaction, 'complete');\n\n    /* Listen to the `error` event */\n    const error$ = this.listenError(transaction);\n\n    /* Choose the first event to occur */\n    return race([complete$, error$]);\n\n  }\n\n}\n","import { Injectable, Inject } from '@angular/core';\nimport { Observable, of, throwError, asyncScheduler } from 'rxjs';\nimport { observeOn } from 'rxjs/operators';\n\nimport { LS_PREFIX } from '../tokens';\nimport { LocalDatabase } from './local-database';\nimport { SerializationError } from './exceptions';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LocalStorageDatabase implements LocalDatabase {\n\n  /**\n   * Optional user prefix to avoid collision for multiple apps on the same subdomain\n   */\n  readonly prefix: string;\n\n  /**\n   * Constructor params are provided by Angular (but can also be passed manually in tests)\n   * @param prefix Prefix option to avoid collision for multiple apps on the same subdomain or for interoperability\n   */\n  constructor(\n    @Inject(LS_PREFIX) prefix = '',\n  ) {\n\n    /* Prefix if asked, or no prefix otherwise */\n    this.prefix = prefix || '';\n\n  }\n\n  /**\n   * Number of items in `localStorage`\n   */\n  get size(): Observable<number> {\n\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(localStorage.length);\n\n  }\n\n  /**\n   * Gets an item value in `localStorage`\n   * @param key The item's key\n   * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`\n   */\n  get(key: string): Observable<unknown | undefined> {\n\n    /* Get raw data */\n    const unparsedData = localStorage.getItem(this.prefixKey(key));\n\n    let parsedData: unknown;\n\n    /* No need to parse if data is `null` or `undefined` */\n    if ((unparsedData !== undefined) && (unparsedData !== null)) {\n\n      /* Try to parse */\n      try {\n        parsedData = JSON.parse(unparsedData);\n      } catch (error) {\n        return throwError(error as SyntaxError);\n      }\n\n    }\n\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(parsedData);\n\n  }\n\n  /**\n   * Store an item in `localStorage`\n   * @param key The item's key\n   * @param data The item's value\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n  set(key: string, data: unknown): Observable<undefined> {\n\n    let serializedData: string | null = null;\n\n    /* Check if data can be serialized */\n    const dataPrototype = Object.getPrototypeOf(data);\n    if ((typeof data === 'object') && (data !== null) && !Array.isArray(data) &&\n    !((dataPrototype === Object.prototype) || (dataPrototype === null))) {\n      return throwError(new SerializationError());\n    }\n\n    /* Try to stringify (can fail on circular references) */\n    try {\n      serializedData = JSON.stringify(data);\n    } catch (error) {\n      return throwError(error as TypeError);\n    }\n\n    /* Can fail if storage quota is exceeded */\n    try {\n      localStorage.setItem(this.prefixKey(key), serializedData);\n    } catch (error) {\n      return throwError(error as DOMException);\n    }\n\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(undefined);\n\n  }\n\n  /**\n   * Deletes an item in `localStorage`\n   * @param key The item's key\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n  delete(key: string): Observable<undefined> {\n\n    localStorage.removeItem(this.prefixKey(key));\n\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(undefined);\n\n  }\n\n  /**\n   * Deletes all items in `localStorage`\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n  clear(): Observable<undefined> {\n\n    localStorage.clear();\n\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(undefined);\n\n  }\n\n  /**\n   * Get all keys in `localStorage`\n   * Note the order of the keys may be inconsistent in Firefox\n   * @returns A RxJS `Observable` iterating on keys\n   */\n  keys(): Observable<string> {\n\n    /* Create an `Observable` from keys */\n    return new Observable<string>((subscriber) => {\n\n      /* Iteretate over all the indexes */\n      for (let index = 0; index < localStorage.length; index += 1) {\n\n        /* Cast as we are sure in this case the key is not `null` */\n        subscriber.next(this.getUnprefixedKey(index) as string);\n\n      }\n\n      subscriber.complete();\n\n    }).pipe(\n      /* Required to work like other databases which are asynchronous */\n      observeOn(asyncScheduler),\n    );\n\n  }\n\n  /**\n   * Check if a key exists in `localStorage`\n   * @param key The item's key\n   * @returns A RxJS `Observable` telling if the key exists or not\n   */\n  has(key: string): Observable<boolean> {\n\n    /* Itérate over all indexes in storage */\n    for (let index = 0; index < localStorage.length; index += 1) {\n\n      if (key === this.getUnprefixedKey(index)) {\n\n        /* Wrap in a RxJS `Observable` to be consistent with other storages */\n        return of(true);\n\n      }\n\n    }\n\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(false);\n\n  }\n\n  /**\n   * Get an unprefixed key\n   * @param index Index of the key\n   * @returns The unprefixed key name if exists, `null` otherwise\n   */\n  protected getUnprefixedKey(index: number): string | null {\n\n    /* Get the key in storage: may have a prefix */\n    const prefixedKey = localStorage.key(index);\n\n    if (prefixedKey !== null) {\n\n      /* If no prefix, the key is already good, otherwrite strip the prefix */\n      return !this.prefix ? prefixedKey : prefixedKey.substr(this.prefix.length);\n\n    }\n\n    return null;\n\n  }\n\n  /**\n   * Add the prefix to a key\n   * @param key The key name\n   * @returns The prefixed key name\n   */\n  protected prefixKey(key: string): string {\n\n    return `${this.prefix}${key}`;\n\n  }\n\n}\n","import { Injectable } from '@angular/core';\nimport { Observable, of, from } from 'rxjs';\n\nimport { LocalDatabase } from './local-database';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MemoryDatabase implements LocalDatabase {\n\n  /**\n   * Memory storage\n   */\n  protected memoryStorage = new Map<string, unknown>();\n\n  /**\n   * Number of items in memory\n   */\n  get size(): Observable<number> {\n\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(this.memoryStorage.size);\n\n  }\n\n  /**\n   * Gets an item value in memory\n   * @param key The item's key\n   * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`\n   */\n   get(key: string): Observable<unknown | undefined> {\n\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(this.memoryStorage.get(key));\n\n  }\n\n  /**\n   * Sets an item in memory\n   * @param key The item's key\n   * @param data The item's value\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n   set(key: string, data: unknown): Observable<undefined> {\n\n    this.memoryStorage.set(key, data);\n\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(undefined);\n\n  }\n\n  /**\n   * Deletes an item in memory\n   * @param key The item's key\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n   delete(key: string): Observable<undefined> {\n\n    this.memoryStorage.delete(key);\n\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(undefined);\n\n  }\n\n  /**\n   * Deletes all items in memory\n   * @returns A RxJS `Observable` to wait the end of the operation\n   */\n   clear(): Observable<undefined> {\n\n    this.memoryStorage.clear();\n\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(undefined);\n\n  }\n\n  /**\n   * Get all keys in memory\n   * @returns A RxJS `Observable` iterating on keys\n   */\n  keys(): Observable<string> {\n\n    /* Create an `Observable` from keys */\n    return from(this.memoryStorage.keys());\n\n  }\n\n  /**\n   * Check if a key exists in memory\n   * @param key Key name\n   * @returns a RxJS `Observable` telling if the key exists or not\n   */\n  has(key: string): Observable<boolean> {\n\n    /* Wrap in a RxJS `Observable` to be consistent with other storages */\n    return of(this.memoryStorage.has(key));\n\n  }\n\n}\n","import { Injectable, PLATFORM_ID } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Observable } from 'rxjs';\n\nimport { IDB_STORE_NAME, IDB_DB_NAME, LS_PREFIX, IDB_DB_VERSION, IDB_NO_WRAP } from '../tokens';\nimport { IndexedDBDatabase } from './indexeddb-database';\nimport { LocalStorageDatabase } from './localstorage-database';\nimport { MemoryDatabase } from './memory-database';\n\n/**\n * Factory to create a storage according to browser support\n * @param platformId Context about the platform (`browser`, `server`...)\n * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain\n * @param IDBDBName `indexedDB` database name\n * @param IDBstoreName `indexedDB` storeName name\n * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/BROWSERS_SUPPORT.md}\n */\nexport function localDatabaseFactory(\n  platformId: string, LSPrefix: string, IDBDBName: string, IDBStoreName: string,\n  IDBDBVersion: number, IDBNoWrap: boolean): LocalDatabase {\n\n  /* When storage is fully disabled in browser (via the \"Block all cookies\" option),\n   * just trying to check `indexedDB` or `localStorage` variables causes a security exception.\n   * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118\n   */\n  try {\n\n    // Do not explicit `window` here, as the global object is not the same in web workers\n    if (isPlatformBrowser(platformId) && (indexedDB !== undefined) && (indexedDB !== null) && ('open' in indexedDB)) {\n\n      /* Check:\n      * - if we are in a browser context (issue: server-side rendering)\n      * - it could exist but be `undefined` or `null` (issue: IE private mode)\n      * - it could exists but not having a working API\n      * Will be the case for:\n      * - All other browsers in normal mode\n      * - Chromium / Safari private mode, but in this case, data will be swiped when the user leaves the app */\n      return new IndexedDBDatabase(IDBDBName, IDBStoreName, IDBDBVersion, IDBNoWrap);\n\n    } else if (isPlatformBrowser(platformId)\n    && (localStorage !== undefined) && (localStorage !== null) && ('getItem' in localStorage)) {\n\n      /* Check:\n      * - if we are in a browser context (issue: server-side rendering)\n      * - if `localStorage` exists (to be sure)\n      * - it could exists but not having a working API\n      * Will be the case for:\n      * - Safari cross-origin iframes, detected later in `IndexedDBDatabase.connect()`\n      * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42}\n      * - IE / Firefox private mode, but in this case, data will be swiped when the user leaves the app\n      * For Firefox, can only be detected later in `IndexedDBDatabase.connect()`\n      * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}\n      */\n      return new LocalStorageDatabase(LSPrefix);\n\n    }\n\n  } catch {}\n\n  /* Will be the case for:\n   * - In browsers if storage has been fully disabled (via the \"Block all cookies\" option)\n   * - Server-side rendering\n   * - All other non-browser context\n   */\n  return new MemoryDatabase();\n\n}\n\n@Injectable({\n  providedIn: 'root',\n  useFactory: localDatabaseFactory,\n  deps: [\n    PLATFORM_ID,\n    LS_PREFIX,\n    IDB_DB_NAME,\n    IDB_STORE_NAME,\n    IDB_DB_VERSION,\n    IDB_NO_WRAP,\n  ]\n})\nexport abstract class LocalDatabase {\n\n  abstract readonly size: Observable<number>;\n\n  abstract get(key: string): Observable<unknown | undefined>;\n  abstract set(key: string, data: unknown): Observable<undefined>;\n  abstract delete(key: string): Observable<undefined>;\n  abstract clear(): Observable<undefined>;\n  abstract keys(): Observable<string>;\n  abstract has(key: string): Observable<boolean>;\n\n}\n","/**\n * Exception message when a value is not valid against the JSON schema\n */\nexport const VALIDATION_ERROR = `Data stored is not valid against the provided JSON schema.\nCheck your JSON schema, otherwise it means data has been corrupted.`;\n\n/**\n * Exception raised when a value is not valid against the JSON schema\n */\nexport class ValidationError extends Error {\n  message = VALIDATION_ERROR;\n}\n","import { Injectable, Inject } from '@angular/core';\nimport { Observable, throwError, of, OperatorFunction, ReplaySubject } from 'rxjs';\nimport { mergeMap, catchError, tap } from 'rxjs/operators';\n\nimport {\n  JSONSchema, JSONSchemaBoolean, JSONSchemaInteger,\n  JSONSchemaNumber, JSONSchemaString, JSONSchemaArrayOf\n} from '../validation/json-schema';\nimport { JSONValidator } from '../validation/json-validator';\nimport { IndexedDBDatabase } from '../databases/indexeddb-database';\nimport { LocalStorageDatabase } from '../databases/localstorage-database';\nimport { MemoryDatabase } from '../databases/memory-database';\nimport { LocalDatabase } from '../databases/local-database';\nimport { IDB_BROKEN_ERROR } from '../databases/exceptions';\nimport { LS_PREFIX } from '../tokens';\nimport { ValidationError } from './exceptions';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class StorageMap {\n\n  protected notifiers = new Map<string, ReplaySubject<unknown>>();\n\n  /**\n   * Constructor params are provided by Angular (but can also be passed manually in tests)\n   * @param database Storage to use\n   * @param jsonValidator Validator service\n   * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain or for interoperability\n   */\n  constructor(\n    protected database: LocalDatabase,\n    protected jsonValidator: JSONValidator = new JSONValidator(),\n    @Inject(LS_PREFIX) protected LSPrefix = '',\n  ) {}\n\n  /**\n   * **Number of items** in storage, wrapped in an `Observable`.\n   *\n   * @example\n   * this.storageMap.size.subscribe((size) => {\n   *   console.log(size);\n   * });\n   */\n  get size(): Observable<number> {\n\n    return this.database.size\n      /* Catch if `indexedDb` is broken */\n      .pipe(this.catchIDBBroken(() => this.database.size));\n\n  }\n\n  /**\n   * Tells you which storage engine is used. *Only useful for interoperability.*\n   * Note that due to some browsers issues in some special contexts\n   * (Firefox private mode and Safari cross-origin iframes),\n   * **this information may be wrong at initialization,**\n   * as the storage could fallback from `indexedDB` to `localStorage`\n   * only after a first read or write operation.\n   * @returns Storage engine used\n   *\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n   *\n   * @example\n   * if (this.storageMap.backingEngine === 'indexedDB') {}\n   */\n  get backingEngine(): 'indexedDB' | 'localStorage' | 'memory' | 'unknown' {\n\n    if (this.database instanceof IndexedDBDatabase) {\n\n      return 'indexedDB';\n\n    } else if (this.database instanceof LocalStorageDatabase) {\n\n      return 'localStorage';\n\n    } else if (this.database instanceof MemoryDatabase) {\n\n      return 'memory';\n\n    } else {\n\n      return 'unknown';\n\n    }\n\n  }\n\n  /**\n   * Info about `indexedDB` database. *Only useful for interoperability.*\n   * @returns `indexedDB` database name, store name and database version.\n   * **Values will be empty if the storage is not `indexedDB`,**\n   * **so it should be used after an engine check**.\n   *\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n   *\n   * @example\n   * if (this.storageMap.backingEngine === 'indexedDB') {\n   *   const { database, store, version } = this.storageMap.backingStore;\n   * }\n   */\n  get backingStore(): { database: string, store: string, version: number } {\n\n    return (this.database instanceof IndexedDBDatabase) ?\n      this.database.backingStore :\n      { database: '', store: '', version: 0 };\n\n  }\n\n  /**\n   * Info about `localStorage` fallback storage. *Only useful for interoperability.*\n   * @returns `localStorage` prefix.\n   * **Values will be empty if the storage is not `localStorage`,**\n   * **so it should be used after an engine check**.\n   *\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}\n   *\n   * @example\n   * if (this.storageMap.backingEngine === 'localStorage') {\n   *   const { prefix } = this.storageMap.fallbackBackingStore;\n   * }\n   */\n  get fallbackBackingStore(): { prefix: string } {\n\n    return (this.database instanceof LocalStorageDatabase) ?\n      { prefix: this.database.prefix } :\n      { prefix: '' };\n\n  }\n\n  /**\n   * Get an item value in storage.\n   * The signature has many overloads due to validation, **please refer to the documentation.**\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   * @param key The item's key\n   * @param schema Optional JSON schema to validate the data\n   * @returns The item's value if the key exists, `undefined` otherwise, wrapped in a RxJS `Observable`\n   *\n   * @example\n   * this.storageMap.get('key', { type: 'string' }).subscribe((result) => {\n   *   result; // string or undefined\n   * });\n   *\n   * @example\n   * interface User {\n   *   firstName: string;\n   *   lastName?: string;\n   * }\n   *\n   * const schema = {\n   *   type: 'object',\n   *   properties: {\n   *     firstName: { type: 'string' },\n   *     lastName: { type: 'string' },\n   *   },\n   *   required: ['firstName']\n   * };\n   *\n   * this.storageMap.get<User>('user', schema).subscribe((user) => {\n   *   if (user) {\n   *     user.firstName;\n   *   }\n   * });\n   */\n  get(key: string): Observable<unknown>;\n  get<T extends string = string>(key: string, schema: JSONSchemaString): Observable<T | undefined>;\n  get<T extends number = number>(key: string, schema: JSONSchemaInteger | JSONSchemaNumber): Observable<T | undefined>;\n  get<T extends boolean = boolean>(key: string, schema: JSONSchemaBoolean): Observable<T | undefined>;\n  get<T extends readonly string[] = string[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaString>): Observable<T | undefined>;\n  get<T extends readonly number[] = number[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaInteger | JSONSchemaNumber>): Observable<T | undefined>;\n  get<T extends readonly boolean[] = boolean[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaBoolean>): Observable<T | undefined>;\n  /**\n   * @deprecated The cast is useless here and doesn't match the JSON schema. Just remove the cast.\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  get<T = string>(key: string, schema: JSONSchemaString): Observable<string | undefined>;\n  /**\n   * @deprecated The cast is useless here and doesn't match the JSON schema. Just remove the cast.\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  get<T = number>(key: string, schema: JSONSchemaInteger | JSONSchemaNumber): Observable<number | undefined>;\n  /**\n   * @deprecated The cast is useless here and doesn't match the JSON schema. Just remove the cast.\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  get<T = boolean>(key: string, schema: JSONSchemaBoolean): Observable<boolean | undefined>;\n  /**\n   * @deprecated The cast is useless here and doesn't match the JSON schema. Just remove the cast.\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  get<T = string[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaString>): Observable<string[] | undefined>;\n  /**\n   * @deprecated The cast is useless here and doesn't match the JSON schema. Just remove the cast.\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  get<T = number[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaInteger | JSONSchemaNumber>): Observable<number[] | undefined>;\n  /**\n   * @deprecated The cast is useless here and doesn't match the JSON schema. Just remove the cast.\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  get<T = boolean[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaBoolean>): Observable<boolean[] | undefined>;\n  /**\n   * @deprecated A cast is required here, otherwise the return will be `unknown` despite a JSON schema was provided.\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  get(key: string, schema: JSONSchema): Observable<unknown | undefined>;\n  get<T>(key: string, schema: JSONSchema): Observable<T | undefined>;\n  /**\n   * @deprecated The cast is useless here: as no JSON schema was provided for validation, the result will still be `unknown`.\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  get<T>(key: string, schema?: JSONSchema): Observable<unknown>;\n  get<T = unknown>(key: string, schema?: JSONSchema): Observable<unknown> {\n\n    /* Get the data in storage */\n    return this.database.get(key).pipe(\n      /* Check if `indexedDb` is broken */\n      this.catchIDBBroken(() => this.database.get(key)),\n      mergeMap((data) => {\n\n        /* No need to validate if the data is empty */\n        if ((data === undefined) || (data === null)) {\n\n          return of(undefined);\n\n        } else if (schema) {\n\n          /* Validate data against a JSON schema if provided */\n          if (!this.jsonValidator.validate(data, schema)) {\n            return throwError(new ValidationError());\n          }\n\n          /* Data have been checked, so it's OK to cast */\n          return of(data as T | undefined);\n\n        }\n\n        /* Cast to unknown as the data wasn't checked */\n        return of(data as unknown);\n\n      }),\n    );\n\n  }\n\n  /**\n   * Set an item in storage.\n   * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.\n   * @param key The item's key\n   * @param data The item's value\n   * @param schema Optional JSON schema to validate the data\n   * @returns A RxJS `Observable` to wait the end of the operation\n   *\n   * @example\n   * this.storageMap.set('key', 'value').subscribe(() => {});\n   */\n  set(key: string, data: unknown, schema?: JSONSchema): Observable<undefined> {\n\n    /* Storing `undefined` or `null` is useless and can cause issues in `indexedDb` in some browsers,\n     * so removing item instead for all storages to have a consistent API */\n    if ((data === undefined) || (data === null)) {\n      return this.delete(key);\n    }\n\n    /* Validate data against a JSON schema if provided */\n    if (schema && !this.jsonValidator.validate(data, schema)) {\n      return throwError(new ValidationError());\n    }\n\n    return this.database.set(key, data).pipe(\n      /* Catch if `indexedDb` is broken */\n      this.catchIDBBroken(() => this.database.set(key, data)),\n      /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n      tap(() => { this.notify(key, data); }),\n    );\n  }\n\n  /**\n   * Delete an item in storage\n   * @param key The item's key\n   * @returns A RxJS `Observable` to wait the end of the operation\n   *\n   * @example\n   * this.storageMap.delete('key').subscribe(() => {});\n   */\n  delete(key: string): Observable<undefined> {\n\n    return this.database.delete(key).pipe(\n      /* Catch if `indexedDb` is broken */\n      this.catchIDBBroken(() => this.database.delete(key)),\n      /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n      tap(() => { this.notify(key, undefined); }),\n    );\n\n  }\n\n  /**\n   * Delete all items in storage\n   * @returns A RxJS `Observable` to wait the end of the operation\n   *\n   * @example\n   * this.storageMap.clear().subscribe(() => {});\n   */\n  clear(): Observable<undefined> {\n\n    return this.database.clear().pipe(\n      /* Catch if `indexedDb` is broken */\n      this.catchIDBBroken(() => this.database.clear()),\n      /* Notify watchers (must be last because it should only happen if the operation succeeds) */\n      tap(() => {\n        for (const key of this.notifiers.keys()) {\n          this.notify(key, undefined);\n        }\n      }),\n    );\n\n  }\n\n  /**\n   * Get all keys stored in storage. Note **this is an *iterating* `Observable`**:\n   * * if there is no key, the `next` callback will not be invoked,\n   * * if you need to wait the whole operation to end, be sure to act in the `complete` callback,\n   * as this `Observable` can emit several values and so will invoke the `next` callback several times.\n   * @returns A list of the keys wrapped in a RxJS `Observable`\n   *\n   * @example\n   * this.storageMap.keys().subscribe({\n   *   next: (key) => { console.log(key); },\n   *   complete: () => { console.log('Done'); },\n   * });\n   */\n  keys(): Observable<string> {\n\n    return this.database.keys()\n      /* Catch if `indexedDb` is broken */\n      .pipe(this.catchIDBBroken(() => this.database.keys()));\n\n  }\n\n  /**\n   * Tells if a key exists in storage\n   * @returns A RxJS `Observable` telling if the key exists\n   *\n   * @example\n   * this.storageMap.has('key').subscribe((hasKey) => {\n   *   if (hasKey) {}\n   * });\n   */\n  has(key: string): Observable<boolean> {\n\n    return this.database.has(key)\n      /* Catch if `indexedDb` is broken */\n      .pipe(this.catchIDBBroken(() => this.database.has(key)));\n\n  }\n\n  /**\n   * Watch an item value in storage.\n   * **Note only changes done via this lib will be watched**, external changes in storage can't be detected.\n   * The signature has many overloads due to validation, **please refer to the documentation.**\n   * @see https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md\n   * @param key The item's key to watch\n   * @param schema Optional JSON schema to validate the initial value\n   * @returns An infinite `Observable` giving the current value\n   */\n  watch(key: string): Observable<unknown>;\n  watch<T extends string = string>(key: string, schema: JSONSchemaString): Observable<T | undefined>;\n  watch<T extends number = number>(key: string, schema: JSONSchemaInteger | JSONSchemaNumber): Observable<T | undefined>;\n  watch<T extends boolean = boolean>(key: string, schema: JSONSchemaBoolean): Observable<T | undefined>;\n  watch<T extends readonly string[] = string[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaString>): Observable<T | undefined>;\n  watch<T extends readonly number[] = number[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaInteger | JSONSchemaNumber>): Observable<T | undefined>;\n  watch<T extends readonly boolean[] = boolean[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaBoolean>): Observable<T | undefined>;\n  /**\n   * @deprecated The cast is useless here and doesn't match the JSON schema. Just remove the cast.\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  watch<T = string>(key: string, schema: JSONSchemaString): Observable<string | undefined>;\n  /**\n   * @deprecated The cast is useless here and doesn't match the JSON schema. Just remove the cast.\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  watch<T = number>(key: string, schema: JSONSchemaInteger | JSONSchemaNumber): Observable<number | undefined>;\n  /**\n   * @deprecated The cast is useless here and doesn't match the JSON schema. Just remove the cast.\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  watch<T = boolean>(key: string, schema: JSONSchemaBoolean): Observable<boolean | undefined>;\n  /**\n   * @deprecated The cast is useless here and doesn't match the JSON schema. Just remove the cast.\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  watch<T = string[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaString>): Observable<string[] | undefined>;\n  /**\n   * @deprecated The cast is useless here and doesn't match the JSON schema. Just remove the cast.\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  watch<T = number[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaInteger | JSONSchemaNumber>): Observable<number[] | undefined>;\n  /**\n   * @deprecated The cast is useless here and doesn't match the JSON schema. Just remove the cast.\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  watch<T = boolean[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaBoolean>): Observable<boolean[] | undefined>;\n  /**\n   * @deprecated A cast is required here, otherwise the return will be `unknown` despite a JSON schema was provided.\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  watch(key: string, schema: JSONSchema): Observable<unknown | undefined>;\n  watch<T>(key: string, schema: JSONSchema): Observable<T | undefined>;\n  /**\n   * @deprecated The cast is useless here: as no JSON schema was provided for validation, the result will still be `unknown`.\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   */\n  watch<T>(key: string, schema?: JSONSchema): Observable<unknown>;\n  watch<T = unknown>(key: string, schema?: JSONSchema): Observable<unknown> {\n\n    /* Check if there is already a notifier */\n    if (!this.notifiers.has(key)) {\n      this.notifiers.set(key, new ReplaySubject(1));\n    }\n\n    /* Non-null assertion is required because TypeScript doesn't narrow `.has()` yet */\n    // tslint:disable-next-line: no-non-null-assertion\n    const notifier = this.notifiers.get(key)!;\n\n    /* Get the current item value */\n    (schema ? this.get<T>(key, schema) : this.get(key)).subscribe({\n      next: (result) => notifier.next(result),\n      error: (error) => notifier.error(error),\n    });\n\n    /* Only the public API of the `Observable` should be returned */\n    return (schema ?\n      notifier.asObservable() as Observable<T | undefined> :\n      notifier.asObservable()\n    );\n\n  }\n\n  /**\n   * Notify when a value changes\n   * @param key The item's key\n   * @param data The new value\n   */\n  protected notify(key: string, value: unknown): void {\n\n    const notifier = this.notifiers.get(key);\n\n    if (notifier) {\n      notifier.next(value);\n    }\n\n  }\n\n  /**\n   * RxJS operator to catch if `indexedDB` is broken\n   * @param operationCallback Callback with the operation to redo\n   */\n  protected catchIDBBroken<T>(operationCallback: () => Observable<T>): OperatorFunction<T, T> {\n\n    return catchError((error) => {\n\n      /* Check if `indexedDB` is broken based on error message (the specific error class seems to be lost in the process) */\n      if ((error !== undefined) && (error !== null) && (error.message === IDB_BROKEN_ERROR)) {\n\n        /* When storage is fully disabled in browser (via the \"Block all cookies\" option),\n         * just trying to check `localStorage` variable causes a security exception.\n         * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118\n         */\n        try {\n\n          if ('getItem' in localStorage) {\n\n            /* Fallback to `localStorage` if available */\n            this.database = new LocalStorageDatabase(this.LSPrefix);\n\n          } else {\n\n            /* Fallback to memory storage otherwise */\n            this.database = new MemoryDatabase();\n\n          }\n\n        } catch {\n\n          /* Fallback to memory storage otherwise */\n          this.database = new MemoryDatabase();\n\n        }\n\n        /* Redo the operation */\n        return operationCallback();\n\n      } else {\n\n        /* Otherwise, rethrow the error */\n        return throwError(error);\n\n      }\n\n    });\n\n  }\n\n}\n","import { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { mapTo, map } from 'rxjs/operators';\n\nimport {\n  JSONSchema, JSONSchemaBoolean, JSONSchemaInteger,\n  JSONSchemaNumber, JSONSchemaString, JSONSchemaArrayOf\n} from '../validation/json-schema';\nimport { StorageMap } from './storage-map.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LocalStorage {\n\n  /**\n   * Number of items in storage wrapped in an `Observable`\n   *\n   * @example\n   * this.localStorage.length.subscribe((length) => {\n   *   console.log(length);\n   * });\n   */\n  get length(): Observable<number> {\n\n    return this.storageMap.size;\n\n  }\n\n  /* Use the `StorageMap` service to avoid code duplication */\n  constructor(protected storageMap: StorageMap) {}\n\n  /**\n   * Get an item value in storage.\n   * The signature has many overloads due to validation, **please refer to the documentation.**\n   * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/VALIDATION.md}\n   * @param key The item's key\n   * @param schema Optional JSON schema to validate the data.\n   * **Note you must pass the schema directly as the second argument.**\n   * **Passing the schema in an object `{ schema }` is deprecated and only here**\n   * **for backward compatibility: it will be removed in a future version.**\n   * @returns The item's value if the key exists, `null` otherwise, wrapped in a RxJS `Observable`\n   *\n   * @example\n   * this.localStorage.get('key', { type: 'string' }).subscribe((result) => {\n   *   result; // string or null\n   * });\n   *\n   * @example\n   * interface User {\n   *   firstName: string;\n   *   lastName?: string;\n   * }\n   *\n   * const schema = {\n   *   type: 'object',\n   *   properties: {\n   *     firstName: { type: 'string' },\n   *     lastName: { type: 'string' },\n   *   },\n   *   required: ['firstName']\n   * };\n   *\n   * this.localStorage.get<User>('user', schema).subscribe((user) => {\n   *   if (user) {\n   *     user.firstName;\n   *   }\n   * });\n   */\n  getItem<T = string>(key: string, schema: JSONSchemaString): Observable<string | null>;\n  getItem<T = number>(key: string, schema: JSONSchemaInteger | JSONSchemaNumber): Observable<number | null>;\n  getItem<T = boolean>(key: string, schema: JSONSchemaBoolean): Observable<boolean | null>;\n  getItem<T = string[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaString>): Observable<string[] | null>;\n  getItem<T = number[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaInteger | JSONSchemaNumber>): Observable<number[] | null>;\n  getItem<T = boolean[]>(key: string, schema: JSONSchemaArrayOf<JSONSchemaBoolean>): Observable<boolean[] | null>;\n  getItem<T = unknown>(key: string, schema: JSONSchema | { schema: JSONSchema }): Observable<T | null>;\n  getItem<T = unknown>(key: string, schema?: JSONSchema): Observable<unknown>;\n  getItem<T = unknown>(key: string, schema?: JSONSchema | { schema: JSONSchema } | undefined): Observable<unknown> {\n\n    if (schema) {\n\n      /* Backward compatibility with version <= 7 */\n      schema = ('schema' in schema) ? schema.schema : schema;\n\n    }\n\n    return (schema ? this.storageMap.get<T>(key, schema) : this.storageMap.get(key)).pipe(\n      /* Transform `undefined` into `null` to align with `localStorage` API */\n      map((value) => (value !== undefined) ? value : null),\n    );\n\n  }\n\n  /**\n   * Set an item in storage.\n   * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.\n   * @param key The item's key\n   * @param data The item's value\n   * @param schema Optional JSON schema to validate the data\n   * @returns A RxJS `Observable` to wait the end of the operation\n   *\n   * @example\n   * this.localStorage.set('key', 'value').subscribe(() => {});\n   */\n  setItem(key: string, data: unknown, schema?: JSONSchema): Observable<boolean> {\n\n    return this.storageMap.set(key, data, schema).pipe(\n      /* Transform `undefined` into `true` for backward compatibility with v7 */\n      mapTo(true),\n    );\n\n  }\n\n  /**\n   * Delete an item in storage\n   * @param key The item's key\n   * @returns A RxJS `Observable` to wait the end of the operation\n   *\n   * @example\n   * this.localStorage.delete('key').subscribe(() => {});\n   */\n  removeItem(key: string): Observable<boolean> {\n\n    return this.storageMap.delete(key).pipe(\n      /* Transform `undefined` into `true` for backward compatibility with v7 */\n      mapTo(true),\n    );\n\n  }\n\n  /**\n   * Delete all items in storage\n   * @returns A RxJS `Observable` to wait the end of the operation\n   *\n   * @example\n   * this.localStorage.clear().subscribe(() => {});\n   */\n  clear(): Observable<boolean> {\n\n    return this.storageMap.clear().pipe(\n      /* Transform `undefined` into `true` for backward compatibility with v7 */\n      mapTo(true),\n    );\n\n  }\n\n}\n","import { NgModule, ModuleWithProviders } from '@angular/core';\n\nimport { LS_PREFIX, IDB_DB_NAME, IDB_STORE_NAME, IDB_DB_VERSION, IDB_NO_WRAP, StorageConfig } from './tokens';\n\n/**\n * This module does not contain anything, it's only useful to provide options via `.forRoot()`.\n */\n@NgModule()\nexport class StorageModule {\n\n  /**\n   * Only useful to provide options, otherwise it does nothing.\n   * **Must be used at initialization, ie. in `AppModule`, and must not be loaded again in another module.**\n   *\n   * @example\n   * NgModule({\n   *   imports: [StorageModule.forRoot({\n   *     LSPrefix: 'custom_',\n   *   })]\n   * })\n   * export class AppModule\n   */\n  static forRoot(config: StorageConfig): ModuleWithProviders<StorageModule> {\n    return {\n      ngModule: StorageModule,\n      providers: [\n        config.LSPrefix ? { provide: LS_PREFIX, useValue: config.LSPrefix } : [],\n        config.IDBDBName ? { provide: IDB_DB_NAME, useValue: config.IDBDBName } : [],\n        config.IDBStoreName ? { provide: IDB_STORE_NAME, useValue: config.IDBStoreName } : [],\n        config.IDBDBVersion ? { provide: IDB_DB_VERSION, useValue: config.IDBDBVersion } : [],\n        (config.IDBNoWrap === false) ? { provide: IDB_NO_WRAP, useValue: config.IDBNoWrap } : [],\n      ],\n    };\n  }\n\n}\n"]}